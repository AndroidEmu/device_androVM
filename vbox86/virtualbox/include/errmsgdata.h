  { "Success.",
    "Success.",
    "VINF_SUCCESS",
     VINF_SUCCESS }, 
  { "General failure - DON'T USE THIS!!!.",
    "General failure - DON'T USE THIS!!!.",
    "VERR_GENERAL_FAILURE",
     VERR_GENERAL_FAILURE }, 
  { "Invalid parameter.",
    "Invalid parameter.",
    "VERR_INVALID_PARAMETER",
     VERR_INVALID_PARAMETER }, 
  { "Invalid parameter.",
    "Invalid parameter.",
    "VWRN_INVALID_PARAMETER",
     VWRN_INVALID_PARAMETER }, 
  { "Invalid magic or cookie.",
    "Invalid magic or cookie.",
    "VERR_INVALID_MAGIC",
     VERR_INVALID_MAGIC }, 
  { "Invalid magic or cookie.",
    "Invalid magic or cookie.",
    "VWRN_INVALID_MAGIC",
     VWRN_INVALID_MAGIC }, 
  { "Invalid loader handle.",
    "Invalid loader handle.",
    "VERR_INVALID_HANDLE",
     VERR_INVALID_HANDLE }, 
  { "Invalid loader handle.",
    "Invalid loader handle.",
    "VWRN_INVALID_HANDLE",
     VWRN_INVALID_HANDLE }, 
  { "Failed to lock the address range.",
    "Failed to lock the address range.",
    "VERR_LOCK_FAILED",
     VERR_LOCK_FAILED }, 
  { "Invalid memory pointer.",
    "Invalid memory pointer.",
    "VERR_INVALID_POINTER",
     VERR_INVALID_POINTER }, 
  { "Failed to patch the IDT.",
    "Failed to patch the IDT.",
    "VERR_IDT_FAILED",
     VERR_IDT_FAILED }, 
  { "Memory allocation failed.",
    "Memory allocation failed.",
    "VERR_NO_MEMORY",
     VERR_NO_MEMORY }, 
  { "Already loaded.",
    "Already loaded.",
    "VERR_ALREADY_LOADED",
     VERR_ALREADY_LOADED }, 
  { "Permission denied.",
    "Permission denied.",
    "VERR_PERMISSION_DENIED",
     VERR_PERMISSION_DENIED }, 
  { "Permission denied.",
    "Permission denied.",
    "VINF_PERMISSION_DENIED",
     VINF_PERMISSION_DENIED }, 
  { "Version mismatch.",
    "Version mismatch.",
    "VERR_VERSION_MISMATCH",
     VERR_VERSION_MISMATCH }, 
  { "The request function is not implemented.",
    "The request function is not implemented.",
    "VERR_NOT_IMPLEMENTED",
     VERR_NOT_IMPLEMENTED }, 
  { "Not equal.",
    "Not equal.",
    "VERR_NOT_EQUAL",
     VERR_NOT_EQUAL }, 
  { "The specified path does not point at a symbolic link.",
    "The specified path does not point at a symbolic link.",
    "VERR_NOT_SYMLINK",
     VERR_NOT_SYMLINK }, 
  { "Failed to allocate temporary memory.",
    "Failed to allocate temporary memory.",
    "VERR_NO_TMP_MEMORY",
     VERR_NO_TMP_MEMORY }, 
  { "Invalid file mode mask (RTFMODE).",
    "Invalid file mode mask (RTFMODE).",
    "VERR_INVALID_FMODE",
     VERR_INVALID_FMODE }, 
  { "Incorrect call order.",
    "Incorrect call order.",
    "VERR_WRONG_ORDER",
     VERR_WRONG_ORDER }, 
  { "There is no TLS (thread local storage) available for storing the current thread.",
    "There is no TLS (thread local storage) available for storing the current thread.",
    "VERR_NO_TLS_FOR_SELF",
     VERR_NO_TLS_FOR_SELF }, 
  { "Failed to set the TLS (thread local storage) entry which points to our thread structure.",
    "Failed to set the TLS (thread local storage) entry which points to our thread structure.",
    "VERR_FAILED_TO_SET_SELF_TLS",
     VERR_FAILED_TO_SET_SELF_TLS }, 
  { "Not able to allocate contiguous memory.",
    "Not able to allocate contiguous memory.",
    "VERR_NO_CONT_MEMORY",
     VERR_NO_CONT_MEMORY }, 
  { "No memory available for page table or page directory.",
    "No memory available for page table or page directory.",
    "VERR_NO_PAGE_MEMORY",
     VERR_NO_PAGE_MEMORY }, 
  { "Already initialized.",
    "Already initialized.",
    "VINF_ALREADY_INITIALIZED",
     VINF_ALREADY_INITIALIZED }, 
  { "The specified thread is dead.",
    "The specified thread is dead.",
    "VERR_THREAD_IS_DEAD",
     VERR_THREAD_IS_DEAD }, 
  { "The specified thread is not waitable.",
    "The specified thread is not waitable.",
    "VERR_THREAD_NOT_WAITABLE",
     VERR_THREAD_NOT_WAITABLE }, 
  { "Pagetable not present.",
    "Pagetable not present.",
    "VERR_PAGE_TABLE_NOT_PRESENT",
     VERR_PAGE_TABLE_NOT_PRESENT }, 
  { "Invalid context.",
    "Invalid context. Typically an API was used by the wrong thread.",
    "VERR_INVALID_CONTEXT",
     VERR_INVALID_CONTEXT }, 
  { "The per process timer is busy.",
    "The per process timer is busy.",
    "VERR_TIMER_BUSY",
     VERR_TIMER_BUSY }, 
  { "Address conflict.",
    "Address conflict.",
    "VERR_ADDRESS_CONFLICT",
     VERR_ADDRESS_CONFLICT }, 
  { "Unresolved (unknown) host platform error.",
    "Unresolved (unknown) host platform error.",
    "VERR_UNRESOLVED_ERROR",
     VERR_UNRESOLVED_ERROR }, 
  { "Invalid function.",
    "Invalid function.",
    "VERR_INVALID_FUNCTION",
     VERR_INVALID_FUNCTION }, 
  { "Not supported.",
    "Not supported.",
    "VERR_NOT_SUPPORTED",
     VERR_NOT_SUPPORTED }, 
  { "Not supported.",
    "Not supported.",
    "VINF_NOT_SUPPORTED",
     VINF_NOT_SUPPORTED }, 
  { "Access denied.",
    "Access denied.",
    "VERR_ACCESS_DENIED",
     VERR_ACCESS_DENIED }, 
  { "Call interrupted.",
    "Call interrupted.",
    "VERR_INTERRUPTED",
     VERR_INTERRUPTED }, 
  { "Call interrupted.",
    "Call interrupted.",
    "VINF_INTERRUPTED",
     VINF_INTERRUPTED }, 
  { "Timeout.",
    "Timeout.",
    "VERR_TIMEOUT",
     VERR_TIMEOUT }, 
  { "Timeout.",
    "Timeout.",
    "VINF_TIMEOUT",
     VINF_TIMEOUT }, 
  { "Buffer too small to save result.",
    "Buffer too small to save result.",
    "VERR_BUFFER_OVERFLOW",
     VERR_BUFFER_OVERFLOW }, 
  { "Buffer too small to save result.",
    "Buffer too small to save result.",
    "VINF_BUFFER_OVERFLOW",
     VINF_BUFFER_OVERFLOW }, 
  { "Data size overflow.",
    "Data size overflow.",
    "VERR_TOO_MUCH_DATA",
     VERR_TOO_MUCH_DATA }, 
  { "Max threads number reached.",
    "Max threads number reached.",
    "VERR_MAX_THRDS_REACHED",
     VERR_MAX_THRDS_REACHED }, 
  { "Max process number reached.",
    "Max process number reached.",
    "VERR_MAX_PROCS_REACHED",
     VERR_MAX_PROCS_REACHED }, 
  { "The recipient process has refused the signal.",
    "The recipient process has refused the signal.",
    "VERR_SIGNAL_REFUSED",
     VERR_SIGNAL_REFUSED }, 
  { "A signal is already pending.",
    "A signal is already pending.",
    "VERR_SIGNAL_PENDING",
     VERR_SIGNAL_PENDING }, 
  { "The signal being posted is not correct.",
    "The signal being posted is not correct.",
    "VERR_SIGNAL_INVALID",
     VERR_SIGNAL_INVALID }, 
  { "The state changed.",
    "The state changed. This is a generic error message and needs a context to make sense.",
    "VERR_STATE_CHANGED",
     VERR_STATE_CHANGED }, 
  { "Warning, the state changed.",
    "Warning, the state changed. This is a generic error message and needs a context to make sense.",
    "VWRN_STATE_CHANGED",
     VWRN_STATE_CHANGED }, 
  { "Error while parsing UUID string.",
    "Error while parsing UUID string.",
    "VERR_INVALID_UUID_FORMAT",
     VERR_INVALID_UUID_FORMAT }, 
  { "The specified process was not found.",
    "The specified process was not found.",
    "VERR_PROCESS_NOT_FOUND",
     VERR_PROCESS_NOT_FOUND }, 
  { "The process specified to a non-block wait had not exited.",
    "The process specified to a non-block wait had not exited.",
    "VERR_PROCESS_RUNNING",
     VERR_PROCESS_RUNNING }, 
  { "Retry the operation.",
    "Retry the operation.",
    "VERR_TRY_AGAIN",
     VERR_TRY_AGAIN }, 
  { "Retry the operation.",
    "Retry the operation.",
    "VINF_TRY_AGAIN",
     VINF_TRY_AGAIN }, 
  { "Generic parse error.",
    "Generic parse error.",
    "VERR_PARSE_ERROR",
     VERR_PARSE_ERROR }, 
  { "Value out of range.",
    "Value out of range.",
    "VERR_OUT_OF_RANGE",
     VERR_OUT_OF_RANGE }, 
  { "A numeric conversion encountered a value which was too big for the target.",
    "A numeric conversion encountered a value which was too big for the target.",
    "VERR_NUMBER_TOO_BIG",
     VERR_NUMBER_TOO_BIG }, 
  { "A numeric conversion encountered a value which was too big for the target.",
    "A numeric conversion encountered a value which was too big for the target.",
    "VWRN_NUMBER_TOO_BIG",
     VWRN_NUMBER_TOO_BIG }, 
  { "The number begin converted (string) contained no digits.",
    "The number begin converted (string) contained no digits.",
    "VERR_NO_DIGITS",
     VERR_NO_DIGITS }, 
  { "The number begin converted (string) contained no digits.",
    "The number begin converted (string) contained no digits.",
    "VWRN_NO_DIGITS",
     VWRN_NO_DIGITS }, 
  { "Encountered a '-' during conversion to an unsigned value.",
    "Encountered a '-' during conversion to an unsigned value.",
    "VERR_NEGATIVE_UNSIGNED",
     VERR_NEGATIVE_UNSIGNED }, 
  { "Encountered a '-' during conversion to an unsigned value.",
    "Encountered a '-' during conversion to an unsigned value.",
    "VWRN_NEGATIVE_UNSIGNED",
     VWRN_NEGATIVE_UNSIGNED }, 
  { "Error while characters translation (unicode and so).",
    "Error while characters translation (unicode and so).",
    "VERR_NO_TRANSLATION",
     VERR_NO_TRANSLATION }, 
  { "Encountered unicode code point which is reserved for use as endian indicator (0xffff or 0xfffe).",
    "Encountered unicode code point which is reserved for use as endian indicator (0xffff or 0xfffe).",
    "VERR_CODE_POINT_ENDIAN_INDICATOR",
     VERR_CODE_POINT_ENDIAN_INDICATOR }, 
  { "Encountered unicode code point in the surrogate range (0xd800 to 0xdfff).",
    "Encountered unicode code point in the surrogate range (0xd800 to 0xdfff).",
    "VERR_CODE_POINT_SURROGATE",
     VERR_CODE_POINT_SURROGATE }, 
  { "A string claiming to be UTF-8 is incorrectly encoded.",
    "A string claiming to be UTF-8 is incorrectly encoded.",
    "VERR_INVALID_UTF8_ENCODING",
     VERR_INVALID_UTF8_ENCODING }, 
  { "Ad string claiming to be in UTF-16 is incorrectly encoded.",
    "Ad string claiming to be in UTF-16 is incorrectly encoded.",
    "VERR_INVALID_UTF16_ENCODING",
     VERR_INVALID_UTF16_ENCODING }, 
  { "Encountered a unicode code point which cannot be represented as UTF-16.",
    "Encountered a unicode code point which cannot be represented as UTF-16.",
    "VERR_CANT_RECODE_AS_UTF16",
     VERR_CANT_RECODE_AS_UTF16 }, 
  { "Got an out of memory condition trying to allocate a string.",
    "Got an out of memory condition trying to allocate a string.",
    "VERR_NO_STR_MEMORY",
     VERR_NO_STR_MEMORY }, 
  { "Got an out of memory condition trying to allocate a UTF-16 (/UCS-2) string.",
    "Got an out of memory condition trying to allocate a UTF-16 (/UCS-2) string.",
    "VERR_NO_UTF16_MEMORY",
     VERR_NO_UTF16_MEMORY }, 
  { "Get an out of memory condition trying to allocate a code point array.",
    "Get an out of memory condition trying to allocate a code point array.",
    "VERR_NO_CODE_POINT_MEMORY",
     VERR_NO_CODE_POINT_MEMORY }, 
  { "Can't free the memory because it's used in mapping.",
    "Can't free the memory because it's used in mapping.",
    "VERR_MEMORY_BUSY",
     VERR_MEMORY_BUSY }, 
  { "The timer can't be started because it's already active.",
    "The timer can't be started because it's already active.",
    "VERR_TIMER_ACTIVE",
     VERR_TIMER_ACTIVE }, 
  { "The timer can't be stopped because i's already suspended.",
    "The timer can't be stopped because i's already suspended.",
    "VERR_TIMER_SUSPENDED",
     VERR_TIMER_SUSPENDED }, 
  { "The operation was cancelled by the user (copy) or another thread (local ipc).",
    "The operation was cancelled by the user (copy) or another thread (local ipc).",
    "VERR_CANCELLED",
     VERR_CANCELLED }, 
  { "Failed to initialize a memory object.",
    "Failed to initialize a memory object. Exactly what this means is OS specific.",
    "VERR_MEMOBJ_INIT_FAILED",
     VERR_MEMOBJ_INIT_FAILED }, 
  { "Out of memory condition when allocating memory with low physical backing.",
    "Out of memory condition when allocating memory with low physical backing.",
    "VERR_NO_LOW_MEMORY",
     VERR_NO_LOW_MEMORY }, 
  { "Out of memory condition when allocating physical memory (without mapping).",
    "Out of memory condition when allocating physical memory (without mapping).",
    "VERR_NO_PHYS_MEMORY",
     VERR_NO_PHYS_MEMORY }, 
  { "The address (virtual or physical) is too big.",
    "The address (virtual or physical) is too big.",
    "VERR_ADDRESS_TOO_BIG",
     VERR_ADDRESS_TOO_BIG }, 
  { "Failed to map a memory object.",
    "Failed to map a memory object.",
    "VERR_MAP_FAILED",
     VERR_MAP_FAILED }, 
  { "Trailing characters.",
    "Trailing characters.",
    "VERR_TRAILING_CHARS",
     VERR_TRAILING_CHARS }, 
  { "Trailing characters.",
    "Trailing characters.",
    "VWRN_TRAILING_CHARS",
     VWRN_TRAILING_CHARS }, 
  { "Trailing spaces.",
    "Trailing spaces.",
    "VERR_TRAILING_SPACES",
     VERR_TRAILING_SPACES }, 
  { "Trailing spaces.",
    "Trailing spaces.",
    "VWRN_TRAILING_SPACES",
     VWRN_TRAILING_SPACES }, 
  { "Generic not found error.",
    "Generic not found error.",
    "VERR_NOT_FOUND",
     VERR_NOT_FOUND }, 
  { "Generic not found warning.",
    "Generic not found warning.",
    "VWRN_NOT_FOUND",
     VWRN_NOT_FOUND }, 
  { "Generic invalid state error.",
    "Generic invalid state error.",
    "VERR_INVALID_STATE",
     VERR_INVALID_STATE }, 
  { "Generic invalid state warning.",
    "Generic invalid state warning.",
    "VWRN_INVALID_STATE",
     VWRN_INVALID_STATE }, 
  { "Generic out of resources error.",
    "Generic out of resources error.",
    "VERR_OUT_OF_RESOURCES",
     VERR_OUT_OF_RESOURCES }, 
  { "Generic out of resources warning.",
    "Generic out of resources warning.",
    "VWRN_OUT_OF_RESOURCES",
     VWRN_OUT_OF_RESOURCES }, 
  { "No more handles available, too many open handles.",
    "No more handles available, too many open handles.",
    "VERR_NO_MORE_HANDLES",
     VERR_NO_MORE_HANDLES }, 
  { "Preemption is disabled.",
    "Preemption is disabled. The requested operation can only be performed when preemption is enabled.",
    "VERR_PREEMPT_DISABLED",
     VERR_PREEMPT_DISABLED }, 
  { "End of string.",
    "End of string.",
    "VERR_END_OF_STRING",
     VERR_END_OF_STRING }, 
  { "End of string.",
    "End of string.",
    "VINF_END_OF_STRING",
     VINF_END_OF_STRING }, 
  { "A page count is out of range.",
    "A page count is out of range.",
    "VERR_PAGE_COUNT_OUT_OF_RANGE",
     VERR_PAGE_COUNT_OUT_OF_RANGE }, 
  { "Generic object destroyed status.",
    "Generic object destroyed status.",
    "VERR_OBJECT_DESTROYED",
     VERR_OBJECT_DESTROYED }, 
  { "Generic object was destroyed by the call status.",
    "Generic object was destroyed by the call status.",
    "VINF_OBJECT_DESTROYED",
     VINF_OBJECT_DESTROYED }, 
  { "Generic dangling objects status.",
    "Generic dangling objects status.",
    "VERR_DANGLING_OBJECTS",
     VERR_DANGLING_OBJECTS }, 
  { "Generic dangling objects status.",
    "Generic dangling objects status.",
    "VWRN_DANGLING_OBJECTS",
     VWRN_DANGLING_OBJECTS }, 
  { "Invalid Base64 encoding.",
    "Invalid Base64 encoding.",
    "VERR_INVALID_BASE64_ENCODING",
     VERR_INVALID_BASE64_ENCODING }, 
  { "Return instigated by a callback or similar.",
    "Return instigated by a callback or similar.",
    "VERR_CALLBACK_RETURN",
     VERR_CALLBACK_RETURN }, 
  { "Return instigated by a callback or similar.",
    "Return instigated by a callback or similar.",
    "VINF_CALLBACK_RETURN",
     VINF_CALLBACK_RETURN }, 
  { "Authentication failure.",
    "Authentication failure.",
    "VERR_AUTHENTICATION_FAILURE",
     VERR_AUTHENTICATION_FAILURE }, 
  { "Not a power of two.",
    "Not a power of two.",
    "VERR_NOT_POWER_OF_TWO",
     VERR_NOT_POWER_OF_TWO }, 
  { "Status code, typically given as a parameter, that isn't supposed to be used.",
    "Status code, typically given as a parameter, that isn't supposed to be used.",
    "VERR_IGNORED",
     VERR_IGNORED }, 
  { "Concurrent access to the object is not allowed.",
    "Concurrent access to the object is not allowed.",
    "VERR_CONCURRENT_ACCESS",
     VERR_CONCURRENT_ACCESS }, 
  { "The caller does not have a reference to the object.",
    "The caller does not have a reference to the object. This status is used when two threads is caught sharing the same object reference.",
    "VERR_CALLER_NO_REFERENCE",
     VERR_CALLER_NO_REFERENCE }, 
  { "Generic no change error.",
    "Generic no change error.",
    "VERR_NO_CHANGE",
     VERR_NO_CHANGE }, 
  { "Generic no change info.",
    "Generic no change info.",
    "VINF_NO_CHANGE",
     VINF_NO_CHANGE }, 
  { "Out of memory condition when allocating executable memory.",
    "Out of memory condition when allocating executable memory.",
    "VERR_NO_EXEC_MEMORY",
     VERR_NO_EXEC_MEMORY }, 
  { "The alignment is not supported.",
    "The alignment is not supported.",
    "VERR_UNSUPPORTED_ALIGNMENT",
     VERR_UNSUPPORTED_ALIGNMENT }, 
  { "The alignment is not really supported, however we got lucky with this allocation.",
    "The alignment is not really supported, however we got lucky with this allocation.",
    "VINF_UNSUPPORTED_ALIGNMENT",
     VINF_UNSUPPORTED_ALIGNMENT }, 
  { "Duplicate something.",
    "Duplicate something.",
    "VERR_DUPLICATE",
     VERR_DUPLICATE }, 
  { "Something is missing.",
    "Something is missing.",
    "VERR_MISSING",
     VERR_MISSING }, 
  { "An unexpected (/unknown) exception was caught.",
    "An unexpected (/unknown) exception was caught.",
    "VERR_UNEXPECTED_EXCEPTION",
     VERR_UNEXPECTED_EXCEPTION }, 
  { "Buffer underflow.",
    "Buffer underflow.",
    "VERR_BUFFER_UNDERFLOW",
     VERR_BUFFER_UNDERFLOW }, 
  { "Buffer underflow.",
    "Buffer underflow.",
    "VINF_BUFFER_UNDERFLOW",
     VINF_BUFFER_UNDERFLOW }, 
  { "Uneven input.",
    "Uneven input.",
    "VERR_UNEVEN_INPUT",
     VERR_UNEVEN_INPUT }, 
  { "Something is not available or not working properly.",
    "Something is not available or not working properly.",
    "VERR_NOT_AVAILABLE",
     VERR_NOT_AVAILABLE }, 
  { "Unresolved (unknown) file i/o error.",
    "Unresolved (unknown) file i/o error.",
    "VERR_FILE_IO_ERROR",
     VERR_FILE_IO_ERROR }, 
  { "File/Device open failed.",
    "File/Device open failed.",
    "VERR_OPEN_FAILED",
     VERR_OPEN_FAILED }, 
  { "File not found.",
    "File not found.",
    "VERR_FILE_NOT_FOUND",
     VERR_FILE_NOT_FOUND }, 
  { "Path not found.",
    "Path not found.",
    "VERR_PATH_NOT_FOUND",
     VERR_PATH_NOT_FOUND }, 
  { "Invalid (malformed) file/path name.",
    "Invalid (malformed) file/path name.",
    "VERR_INVALID_NAME",
     VERR_INVALID_NAME }, 
  { "The object in question already exists.",
    "The object in question already exists.",
    "VERR_ALREADY_EXISTS",
     VERR_ALREADY_EXISTS }, 
  { "The object in question already exists.",
    "The object in question already exists.",
    "VWRN_ALREADY_EXISTS",
     VWRN_ALREADY_EXISTS }, 
  { "Too many open files.",
    "Too many open files.",
    "VERR_TOO_MANY_OPEN_FILES",
     VERR_TOO_MANY_OPEN_FILES }, 
  { "Seek error.",
    "Seek error.",
    "VERR_SEEK",
     VERR_SEEK }, 
  { "Seek below file start.",
    "Seek below file start.",
    "VERR_NEGATIVE_SEEK",
     VERR_NEGATIVE_SEEK }, 
  { "Trying to seek on device.",
    "Trying to seek on device.",
    "VERR_SEEK_ON_DEVICE",
     VERR_SEEK_ON_DEVICE }, 
  { "Reached the end of the file.",
    "Reached the end of the file.",
    "VERR_EOF",
     VERR_EOF }, 
  { "Reached the end of the file.",
    "Reached the end of the file.",
    "VINF_EOF",
     VINF_EOF }, 
  { "Generic file read error.",
    "Generic file read error.",
    "VERR_READ_ERROR",
     VERR_READ_ERROR }, 
  { "Generic file write error.",
    "Generic file write error.",
    "VERR_WRITE_ERROR",
     VERR_WRITE_ERROR }, 
  { "Write protect error.",
    "Write protect error.",
    "VERR_WRITE_PROTECT",
     VERR_WRITE_PROTECT }, 
  { "Sharing violation, file is being used by another process.",
    "Sharing violation, file is being used by another process.",
    "VERR_SHARING_VIOLATION",
     VERR_SHARING_VIOLATION }, 
  { "Unable to lock a region of a file.",
    "Unable to lock a region of a file.",
    "VERR_FILE_LOCK_FAILED",
     VERR_FILE_LOCK_FAILED }, 
  { "File access error, another process has locked a portion of the file.",
    "File access error, another process has locked a portion of the file.",
    "VERR_FILE_LOCK_VIOLATION",
     VERR_FILE_LOCK_VIOLATION }, 
  { "File or directory can't be created.",
    "File or directory can't be created.",
    "VERR_CANT_CREATE",
     VERR_CANT_CREATE }, 
  { "Directory can't be deleted.",
    "Directory can't be deleted.",
    "VERR_CANT_DELETE_DIRECTORY",
     VERR_CANT_DELETE_DIRECTORY }, 
  { "Can't move file to another disk.",
    "Can't move file to another disk.",
    "VERR_NOT_SAME_DEVICE",
     VERR_NOT_SAME_DEVICE }, 
  { "The filename or extension is too long.",
    "The filename or extension is too long.",
    "VERR_FILENAME_TOO_LONG",
     VERR_FILENAME_TOO_LONG }, 
  { "Media not present in drive.",
    "Media not present in drive.",
    "VERR_MEDIA_NOT_PRESENT",
     VERR_MEDIA_NOT_PRESENT }, 
  { "The type of media was not recognized.",
    "The type of media was not recognized. Not formatted?.",
    "VERR_MEDIA_NOT_RECOGNIZED",
     VERR_MEDIA_NOT_RECOGNIZED }, 
  { "Can't unlock - region was not locked.",
    "Can't unlock - region was not locked.",
    "VERR_FILE_NOT_LOCKED",
     VERR_FILE_NOT_LOCKED }, 
  { "Unrecoverable error: lock was lost.",
    "Unrecoverable error: lock was lost.",
    "VERR_FILE_LOCK_LOST",
     VERR_FILE_LOCK_LOST }, 
  { "Can't delete directory with files.",
    "Can't delete directory with files.",
    "VERR_DIR_NOT_EMPTY",
     VERR_DIR_NOT_EMPTY }, 
  { "A directory operation was attempted on a non-directory object.",
    "A directory operation was attempted on a non-directory object.",
    "VERR_NOT_A_DIRECTORY",
     VERR_NOT_A_DIRECTORY }, 
  { "A non-directory operation was attempted on a directory object.",
    "A non-directory operation was attempted on a directory object.",
    "VERR_IS_A_DIRECTORY",
     VERR_IS_A_DIRECTORY }, 
  { "Tried to grow a file beyond the limit imposed by the process or the filesystem.",
    "Tried to grow a file beyond the limit imposed by the process or the filesystem.",
    "VERR_FILE_TOO_BIG",
     VERR_FILE_TOO_BIG }, 
  { "No pending request the aio context has to wait for completion.",
    "No pending request the aio context has to wait for completion.",
    "VERR_FILE_AIO_NO_REQUEST",
     VERR_FILE_AIO_NO_REQUEST }, 
  { "The request could not be canceled or prepared for another transfer because it is still in progress.",
    "The request could not be canceled or prepared for another transfer because it is still in progress.",
    "VERR_FILE_AIO_IN_PROGRESS",
     VERR_FILE_AIO_IN_PROGRESS }, 
  { "The request could not be canceled because it already completed.",
    "The request could not be canceled because it already completed.",
    "VERR_FILE_AIO_COMPLETED",
     VERR_FILE_AIO_COMPLETED }, 
  { "The I/O context couldn't be destroyed because there are still pending requests.",
    "The I/O context couldn't be destroyed because there are still pending requests.",
    "VERR_FILE_AIO_BUSY",
     VERR_FILE_AIO_BUSY }, 
  { "The requests couldn't be submitted because that would exceed the capacity of the context.",
    "The requests couldn't be submitted because that would exceed the capacity of the context.",
    "VERR_FILE_AIO_LIMIT_EXCEEDED",
     VERR_FILE_AIO_LIMIT_EXCEEDED }, 
  { "The request was canceled.",
    "The request was canceled.",
    "VERR_FILE_AIO_CANCELED",
     VERR_FILE_AIO_CANCELED }, 
  { "The request wasn't submitted so it can't be canceled.",
    "The request wasn't submitted so it can't be canceled.",
    "VERR_FILE_AIO_NOT_SUBMITTED",
     VERR_FILE_AIO_NOT_SUBMITTED }, 
  { "A request was not prepared and thus could not be submitted.",
    "A request was not prepared and thus could not be submitted.",
    "VERR_FILE_AIO_NOT_PREPARED",
     VERR_FILE_AIO_NOT_PREPARED }, 
  { "Not all requests could be submitted due to resource shortage.",
    "Not all requests could be submitted due to resource shortage.",
    "VERR_FILE_AIO_INSUFFICIENT_RESSOURCES",
     VERR_FILE_AIO_INSUFFICIENT_RESSOURCES }, 
  { "Device or resource is busy.",
    "Device or resource is busy.",
    "VERR_RESOURCE_BUSY",
     VERR_RESOURCE_BUSY }, 
  { "A file operation was attempted on a non-file object.",
    "A file operation was attempted on a non-file object.",
    "VERR_NOT_A_FILE",
     VERR_NOT_A_FILE }, 
  { "A non-file operation was attempted on a file object.",
    "A non-file operation was attempted on a file object.",
    "VERR_IS_A_FILE",
     VERR_IS_A_FILE }, 
  { "Unexpected filesystem object type.",
    "Unexpected filesystem object type.",
    "VERR_UNEXPECTED_FS_OBJ_TYPE",
     VERR_UNEXPECTED_FS_OBJ_TYPE }, 
  { "A path does not start with a root specification.",
    "A path does not start with a root specification.",
    "VERR_PATH_DOES_NOT_START_WITH_ROOT",
     VERR_PATH_DOES_NOT_START_WITH_ROOT }, 
  { "A path is relative, expected an absolute path.",
    "A path is relative, expected an absolute path.",
    "VERR_PATH_IS_RELATIVE",
     VERR_PATH_IS_RELATIVE }, 
  { "A path is not relative (start with root), expected an relative path.",
    "A path is not relative (start with root), expected an relative path.",
    "VERR_PATH_IS_NOT_RELATIVE",
     VERR_PATH_IS_NOT_RELATIVE }, 
  { "Unresolved (unknown) disk i/o error.",
    "Unresolved (unknown) disk i/o error.",
    "VERR_DISK_IO_ERROR",
     VERR_DISK_IO_ERROR }, 
  { "Invalid drive number.",
    "Invalid drive number.",
    "VERR_INVALID_DRIVE",
     VERR_INVALID_DRIVE }, 
  { "Disk is full.",
    "Disk is full.",
    "VERR_DISK_FULL",
     VERR_DISK_FULL }, 
  { "Disk was changed.",
    "Disk was changed.",
    "VERR_DISK_CHANGE",
     VERR_DISK_CHANGE }, 
  { "Drive is locked.",
    "Drive is locked.",
    "VERR_DRIVE_LOCKED",
     VERR_DRIVE_LOCKED }, 
  { "The specified disk or diskette cannot be accessed.",
    "The specified disk or diskette cannot be accessed.",
    "VERR_DISK_INVALID_FORMAT",
     VERR_DISK_INVALID_FORMAT }, 
  { "Too many symbolic links.",
    "Too many symbolic links.",
    "VERR_TOO_MANY_SYMLINKS",
     VERR_TOO_MANY_SYMLINKS }, 
  { "The OS does not support setting the time stamps on a symbolic link.",
    "The OS does not support setting the time stamps on a symbolic link.",
    "VERR_NS_SYMLINK_SET_TIME",
     VERR_NS_SYMLINK_SET_TIME }, 
  { "The OS does not support changing the owner of a symbolic link.",
    "The OS does not support changing the owner of a symbolic link.",
    "VERR_NS_SYMLINK_CHANGE_OWNER",
     VERR_NS_SYMLINK_CHANGE_OWNER }, 
  { "Unresolved (unknown) search error.",
    "Unresolved (unknown) search error.",
    "VERR_SEARCH_ERROR",
     VERR_SEARCH_ERROR }, 
  { "No more files found.",
    "No more files found.",
    "VERR_NO_MORE_FILES",
     VERR_NO_MORE_FILES }, 
  { "No more search handles available.",
    "No more search handles available.",
    "VERR_NO_MORE_SEARCH_HANDLES",
     VERR_NO_MORE_SEARCH_HANDLES }, 
  { "RTDirReadEx() failed to retrieve the extra data which was requested.",
    "RTDirReadEx() failed to retrieve the extra data which was requested.",
    "VWRN_NO_DIRENT_INFO",
     VWRN_NO_DIRENT_INFO }, 
  { "Internal error - this should never happen.",
    "Internal error - this should never happen.",
    "VERR_INTERNAL_ERROR",
     VERR_INTERNAL_ERROR }, 
  { "Internal error no.",
    "Internal error no. 2.",
    "VERR_INTERNAL_ERROR_2",
     VERR_INTERNAL_ERROR_2 }, 
  { "Internal error no.",
    "Internal error no. 3.",
    "VERR_INTERNAL_ERROR_3",
     VERR_INTERNAL_ERROR_3 }, 
  { "Internal error no.",
    "Internal error no. 4.",
    "VERR_INTERNAL_ERROR_4",
     VERR_INTERNAL_ERROR_4 }, 
  { "Internal error no.",
    "Internal error no. 5.",
    "VERR_INTERNAL_ERROR_5",
     VERR_INTERNAL_ERROR_5 }, 
  { "Internal error: Unexpected status code.",
    "Internal error: Unexpected status code.",
    "VERR_IPE_UNEXPECTED_STATUS",
     VERR_IPE_UNEXPECTED_STATUS }, 
  { "Internal error: Unexpected status code.",
    "Internal error: Unexpected status code.",
    "VERR_IPE_UNEXPECTED_INFO_STATUS",
     VERR_IPE_UNEXPECTED_INFO_STATUS }, 
  { "Internal error: Unexpected status code.",
    "Internal error: Unexpected status code.",
    "VERR_IPE_UNEXPECTED_ERROR_STATUS",
     VERR_IPE_UNEXPECTED_ERROR_STATUS }, 
  { "Internal error: Uninitialized status code.",
    "Internal error: Uninitialized status code. @remarks This is used by value elsewhere.",
    "VERR_IPE_UNINITIALIZED_STATUS",
     VERR_IPE_UNINITIALIZED_STATUS }, 
  { "Internal error: Supposedly unreachable default case in a switch.",
    "Internal error: Supposedly unreachable default case in a switch.",
    "VERR_IPE_NOT_REACHED_DEFAULT_CASE",
     VERR_IPE_NOT_REACHED_DEFAULT_CASE }, 
  { "Unresolved (unknown) device i/o error.",
    "Unresolved (unknown) device i/o error.",
    "VERR_DEV_IO_ERROR",
     VERR_DEV_IO_ERROR }, 
  { "Device i/o: Bad unit.",
    "Device i/o: Bad unit.",
    "VERR_IO_BAD_UNIT",
     VERR_IO_BAD_UNIT }, 
  { "Device i/o: Not ready.",
    "Device i/o: Not ready.",
    "VERR_IO_NOT_READY",
     VERR_IO_NOT_READY }, 
  { "Device i/o: Bad command.",
    "Device i/o: Bad command.",
    "VERR_IO_BAD_COMMAND",
     VERR_IO_BAD_COMMAND }, 
  { "Device i/o: CRC error.",
    "Device i/o: CRC error.",
    "VERR_IO_CRC",
     VERR_IO_CRC }, 
  { "Device i/o: Bad length.",
    "Device i/o: Bad length.",
    "VERR_IO_BAD_LENGTH",
     VERR_IO_BAD_LENGTH }, 
  { "Device i/o: Sector not found.",
    "Device i/o: Sector not found.",
    "VERR_IO_SECTOR_NOT_FOUND",
     VERR_IO_SECTOR_NOT_FOUND }, 
  { "Device i/o: General failure.",
    "Device i/o: General failure.",
    "VERR_IO_GEN_FAILURE",
     VERR_IO_GEN_FAILURE }, 
  { "Unresolved (unknown) pipe i/o error.",
    "Unresolved (unknown) pipe i/o error.",
    "VERR_PIPE_IO_ERROR",
     VERR_PIPE_IO_ERROR }, 
  { "Broken pipe.",
    "Broken pipe.",
    "VERR_BROKEN_PIPE",
     VERR_BROKEN_PIPE }, 
  { "Bad pipe.",
    "Bad pipe.",
    "VERR_BAD_PIPE",
     VERR_BAD_PIPE }, 
  { "Pipe is busy.",
    "Pipe is busy.",
    "VERR_PIPE_BUSY",
     VERR_PIPE_BUSY }, 
  { "No data in pipe.",
    "No data in pipe.",
    "VERR_NO_DATA",
     VERR_NO_DATA }, 
  { "Pipe is not connected.",
    "Pipe is not connected.",
    "VERR_PIPE_NOT_CONNECTED",
     VERR_PIPE_NOT_CONNECTED }, 
  { "More data available in pipe.",
    "More data available in pipe.",
    "VERR_MORE_DATA",
     VERR_MORE_DATA }, 
  { "Expected read pipe, got a write pipe instead.",
    "Expected read pipe, got a write pipe instead.",
    "VERR_PIPE_NOT_READ",
     VERR_PIPE_NOT_READ }, 
  { "Expected write pipe, got a read pipe instead.",
    "Expected write pipe, got a read pipe instead.",
    "VERR_PIPE_NOT_WRITE",
     VERR_PIPE_NOT_WRITE }, 
  { "Unresolved (unknown) semaphore error.",
    "Unresolved (unknown) semaphore error.",
    "VERR_SEM_ERROR",
     VERR_SEM_ERROR }, 
  { "Too many semaphores.",
    "Too many semaphores.",
    "VERR_TOO_MANY_SEMAPHORES",
     VERR_TOO_MANY_SEMAPHORES }, 
  { "Exclusive semaphore is owned by another process.",
    "Exclusive semaphore is owned by another process.",
    "VERR_EXCL_SEM_ALREADY_OWNED",
     VERR_EXCL_SEM_ALREADY_OWNED }, 
  { "The semaphore is set and cannot be closed.",
    "The semaphore is set and cannot be closed.",
    "VERR_SEM_IS_SET",
     VERR_SEM_IS_SET }, 
  { "The semaphore cannot be set again.",
    "The semaphore cannot be set again.",
    "VERR_TOO_MANY_SEM_REQUESTS",
     VERR_TOO_MANY_SEM_REQUESTS }, 
  { "Attempt to release mutex not owned by caller.",
    "Attempt to release mutex not owned by caller.",
    "VERR_NOT_OWNER",
     VERR_NOT_OWNER }, 
  { "The semaphore has been opened too many times.",
    "The semaphore has been opened too many times.",
    "VERR_TOO_MANY_OPENS",
     VERR_TOO_MANY_OPENS }, 
  { "The maximum posts for the event semaphore has been reached.",
    "The maximum posts for the event semaphore has been reached.",
    "VERR_TOO_MANY_POSTS",
     VERR_TOO_MANY_POSTS }, 
  { "The event semaphore has already been posted.",
    "The event semaphore has already been posted.",
    "VERR_ALREADY_POSTED",
     VERR_ALREADY_POSTED }, 
  { "The event semaphore has already been reset.",
    "The event semaphore has already been reset.",
    "VERR_ALREADY_RESET",
     VERR_ALREADY_RESET }, 
  { "The semaphore is in use.",
    "The semaphore is in use.",
    "VERR_SEM_BUSY",
     VERR_SEM_BUSY }, 
  { "The previous ownership of this semaphore has ended.",
    "The previous ownership of this semaphore has ended.",
    "VERR_SEM_OWNER_DIED",
     VERR_SEM_OWNER_DIED }, 
  { "Failed to open semaphore by name - not found.",
    "Failed to open semaphore by name - not found.",
    "VERR_SEM_NOT_FOUND",
     VERR_SEM_NOT_FOUND }, 
  { "Semaphore destroyed while waiting.",
    "Semaphore destroyed while waiting.",
    "VERR_SEM_DESTROYED",
     VERR_SEM_DESTROYED }, 
  { "Nested ownership requests are not permitted for this semaphore type.",
    "Nested ownership requests are not permitted for this semaphore type.",
    "VERR_SEM_NESTED",
     VERR_SEM_NESTED }, 
  { "The release call only release a semaphore nesting, i.",
    "The release call only release a semaphore nesting, i.e. the caller is still holding the semaphore.",
    "VINF_SEM_NESTED",
     VINF_SEM_NESTED }, 
  { "Deadlock detected.",
    "Deadlock detected.",
    "VERR_DEADLOCK",
     VERR_DEADLOCK }, 
  { "Ping-Pong listen or speak out of turn error.",
    "Ping-Pong listen or speak out of turn error.",
    "VERR_SEM_OUT_OF_TURN",
     VERR_SEM_OUT_OF_TURN }, 
  { "Tried to take a semaphore in a bad context.",
    "Tried to take a semaphore in a bad context.",
    "VERR_SEM_BAD_CONTEXT",
     VERR_SEM_BAD_CONTEXT }, 
  { "Don't spin for the semaphore, but it is safe to try grab it.",
    "Don't spin for the semaphore, but it is safe to try grab it.",
    "VINF_SEM_BAD_CONTEXT",
     VINF_SEM_BAD_CONTEXT }, 
  { "Wrong locking order detected.",
    "Wrong locking order detected.",
    "VERR_SEM_LV_WRONG_ORDER",
     VERR_SEM_LV_WRONG_ORDER }, 
  { "Wrong release order detected.",
    "Wrong release order detected.",
    "VERR_SEM_LV_WRONG_RELEASE_ORDER",
     VERR_SEM_LV_WRONG_RELEASE_ORDER }, 
  { "Attempt to recursively enter a non-recurisve lock.",
    "Attempt to recursively enter a non-recurisve lock.",
    "VERR_SEM_LV_NESTED",
     VERR_SEM_LV_NESTED }, 
  { "Invalid parameters passed to the lock validator.",
    "Invalid parameters passed to the lock validator.",
    "VERR_SEM_LV_INVALID_PARAMETER",
     VERR_SEM_LV_INVALID_PARAMETER }, 
  { "The lock validator detected a deadlock.",
    "The lock validator detected a deadlock.",
    "VERR_SEM_LV_DEADLOCK",
     VERR_SEM_LV_DEADLOCK }, 
  { "The lock validator detected an existing deadlock.",
    "The lock validator detected an existing deadlock. The deadlock was not caused by the current operation, but existed already.",
    "VERR_SEM_LV_EXISTING_DEADLOCK",
     VERR_SEM_LV_EXISTING_DEADLOCK }, 
  { "Not the lock owner according our records.",
    "Not the lock owner according our records.",
    "VERR_SEM_LV_NOT_OWNER",
     VERR_SEM_LV_NOT_OWNER }, 
  { "An illegal lock upgrade was attempted.",
    "An illegal lock upgrade was attempted.",
    "VERR_SEM_LV_ILLEGAL_UPGRADE",
     VERR_SEM_LV_ILLEGAL_UPGRADE }, 
  { "The thread is not a valid signaller of the event.",
    "The thread is not a valid signaller of the event.",
    "VERR_SEM_LV_NOT_SIGNALLER",
     VERR_SEM_LV_NOT_SIGNALLER }, 
  { "Internal error in the lock validator or related components.",
    "Internal error in the lock validator or related components.",
    "VERR_SEM_LV_INTERNAL_ERROR",
     VERR_SEM_LV_INTERNAL_ERROR }, 
  { "Unresolved (unknown) network error.",
    "Unresolved (unknown) network error.",
    "VERR_NET_IO_ERROR",
     VERR_NET_IO_ERROR }, 
  { "The network is busy or is out of resources.",
    "The network is busy or is out of resources.",
    "VERR_NET_OUT_OF_RESOURCES",
     VERR_NET_OUT_OF_RESOURCES }, 
  { "Net host name not found.",
    "Net host name not found.",
    "VERR_NET_HOST_NOT_FOUND",
     VERR_NET_HOST_NOT_FOUND }, 
  { "Network path not found.",
    "Network path not found.",
    "VERR_NET_PATH_NOT_FOUND",
     VERR_NET_PATH_NOT_FOUND }, 
  { "General network printing error.",
    "General network printing error.",
    "VERR_NET_PRINT_ERROR",
     VERR_NET_PRINT_ERROR }, 
  { "The machine is not on the network.",
    "The machine is not on the network.",
    "VERR_NET_NO_NETWORK",
     VERR_NET_NO_NETWORK }, 
  { "Name is not unique on the network.",
    "Name is not unique on the network.",
    "VERR_NET_NOT_UNIQUE_NAME",
     VERR_NET_NOT_UNIQUE_NAME }, 
  { "Operation in progress.",
    "Operation in progress.",
    "VERR_NET_IN_PROGRESS",
     VERR_NET_IN_PROGRESS }, 
  { "Operation already in progress.",
    "Operation already in progress.",
    "VERR_NET_ALREADY_IN_PROGRESS",
     VERR_NET_ALREADY_IN_PROGRESS }, 
  { "Attempted socket operation with a non-socket handle.",
    "Attempted socket operation with a non-socket handle. (This includes closed handles.).",
    "VERR_NET_NOT_SOCKET",
     VERR_NET_NOT_SOCKET }, 
  { "Destination address required.",
    "Destination address required.",
    "VERR_NET_DEST_ADDRESS_REQUIRED",
     VERR_NET_DEST_ADDRESS_REQUIRED }, 
  { "Message too long.",
    "Message too long.",
    "VERR_NET_MSG_SIZE",
     VERR_NET_MSG_SIZE }, 
  { "Protocol wrong type for socket.",
    "Protocol wrong type for socket.",
    "VERR_NET_PROTOCOL_TYPE",
     VERR_NET_PROTOCOL_TYPE }, 
  { "Protocol not available.",
    "Protocol not available.",
    "VERR_NET_PROTOCOL_NOT_AVAILABLE",
     VERR_NET_PROTOCOL_NOT_AVAILABLE }, 
  { "Protocol not supported.",
    "Protocol not supported.",
    "VERR_NET_PROTOCOL_NOT_SUPPORTED",
     VERR_NET_PROTOCOL_NOT_SUPPORTED }, 
  { "Socket type not supported.",
    "Socket type not supported.",
    "VERR_NET_SOCKET_TYPE_NOT_SUPPORTED",
     VERR_NET_SOCKET_TYPE_NOT_SUPPORTED }, 
  { "Operation not supported.",
    "Operation not supported.",
    "VERR_NET_OPERATION_NOT_SUPPORTED",
     VERR_NET_OPERATION_NOT_SUPPORTED }, 
  { "Protocol family not supported.",
    "Protocol family not supported.",
    "VERR_NET_PROTOCOL_FAMILY_NOT_SUPPORTED",
     VERR_NET_PROTOCOL_FAMILY_NOT_SUPPORTED }, 
  { "Address family not supported by protocol family.",
    "Address family not supported by protocol family.",
    "VERR_NET_ADDRESS_FAMILY_NOT_SUPPORTED",
     VERR_NET_ADDRESS_FAMILY_NOT_SUPPORTED }, 
  { "Address already in use.",
    "Address already in use.",
    "VERR_NET_ADDRESS_IN_USE",
     VERR_NET_ADDRESS_IN_USE }, 
  { "Can't assign requested address.",
    "Can't assign requested address.",
    "VERR_NET_ADDRESS_NOT_AVAILABLE",
     VERR_NET_ADDRESS_NOT_AVAILABLE }, 
  { "Network is down.",
    "Network is down.",
    "VERR_NET_DOWN",
     VERR_NET_DOWN }, 
  { "Network is unreachable.",
    "Network is unreachable.",
    "VERR_NET_UNREACHABLE",
     VERR_NET_UNREACHABLE }, 
  { "Network dropped connection on reset.",
    "Network dropped connection on reset.",
    "VERR_NET_CONNECTION_RESET",
     VERR_NET_CONNECTION_RESET }, 
  { "Software caused connection abort.",
    "Software caused connection abort.",
    "VERR_NET_CONNECTION_ABORTED",
     VERR_NET_CONNECTION_ABORTED }, 
  { "Connection reset by peer.",
    "Connection reset by peer.",
    "VERR_NET_CONNECTION_RESET_BY_PEER",
     VERR_NET_CONNECTION_RESET_BY_PEER }, 
  { "No buffer space available.",
    "No buffer space available.",
    "VERR_NET_NO_BUFFER_SPACE",
     VERR_NET_NO_BUFFER_SPACE }, 
  { "Socket is already connected.",
    "Socket is already connected.",
    "VERR_NET_ALREADY_CONNECTED",
     VERR_NET_ALREADY_CONNECTED }, 
  { "Socket is not connected.",
    "Socket is not connected.",
    "VERR_NET_NOT_CONNECTED",
     VERR_NET_NOT_CONNECTED }, 
  { "Can't send after socket shutdown.",
    "Can't send after socket shutdown.",
    "VERR_NET_SHUTDOWN",
     VERR_NET_SHUTDOWN }, 
  { "Too many references: can't splice.",
    "Too many references: can't splice.",
    "VERR_NET_TOO_MANY_REFERENCES",
     VERR_NET_TOO_MANY_REFERENCES }, 
  { "Too many references: can't splice.",
    "Too many references: can't splice.",
    "VERR_NET_CONNECTION_TIMED_OUT",
     VERR_NET_CONNECTION_TIMED_OUT }, 
  { "Connection refused.",
    "Connection refused.",
    "VERR_NET_CONNECTION_REFUSED",
     VERR_NET_CONNECTION_REFUSED }, 
  { "Host is down.",
    "Host is down.",
    "VERR_NET_HOST_DOWN",
     VERR_NET_HOST_DOWN }, 
  { "No route to host.",
    "No route to host.",
    "VERR_NET_HOST_UNREACHABLE",
     VERR_NET_HOST_UNREACHABLE }, 
  { "Protocol error.",
    "Protocol error.",
    "VERR_NET_PROTOCOL_ERROR",
     VERR_NET_PROTOCOL_ERROR }, 
  { "Stop the TCP server.",
    "Stop the TCP server.",
    "VERR_TCP_SERVER_STOP",
     VERR_TCP_SERVER_STOP }, 
  { "The server was stopped.",
    "The server was stopped.",
    "VINF_TCP_SERVER_STOP",
     VINF_TCP_SERVER_STOP }, 
  { "The TCP server was shut down using RTTcpServerShutdown.",
    "The TCP server was shut down using RTTcpServerShutdown.",
    "VERR_TCP_SERVER_SHUTDOWN",
     VERR_TCP_SERVER_SHUTDOWN }, 
  { "The TCP server was destroyed.",
    "The TCP server was destroyed.",
    "VERR_TCP_SERVER_DESTROYED",
     VERR_TCP_SERVER_DESTROYED }, 
  { "The TCP server has no client associated with it.",
    "The TCP server has no client associated with it.",
    "VINF_TCP_SERVER_NO_CLIENT",
     VINF_TCP_SERVER_NO_CLIENT }, 
  { "Stop the UDP server.",
    "Stop the UDP server.",
    "VERR_UDP_SERVER_STOP",
     VERR_UDP_SERVER_STOP }, 
  { "The server was stopped.",
    "The server was stopped.",
    "VINF_UDP_SERVER_STOP",
     VINF_UDP_SERVER_STOP }, 
  { "The UDP server was shut down using RTUdpServerShutdown.",
    "The UDP server was shut down using RTUdpServerShutdown.",
    "VERR_UDP_SERVER_SHUTDOWN",
     VERR_UDP_SERVER_SHUTDOWN }, 
  { "The UDP server was destroyed.",
    "The UDP server was destroyed.",
    "VERR_UDP_SERVER_DESTROYED",
     VERR_UDP_SERVER_DESTROYED }, 
  { "The UDP server has no client associated with it.",
    "The UDP server has no client associated with it.",
    "VINF_UDP_SERVER_NO_CLIENT",
     VINF_UDP_SERVER_NO_CLIENT }, 
  { "Invalid offset in an L4 dataspace.",
    "Invalid offset in an L4 dataspace.",
    "VERR_L4_INVALID_DS_OFFSET",
     VERR_L4_INVALID_DS_OFFSET }, 
  { "IPC error.",
    "IPC error.",
    "VERR_IPC",
     VERR_IPC }, 
  { "Item already used.",
    "Item already used.",
    "VERR_RESOURCE_IN_USE",
     VERR_RESOURCE_IN_USE }, 
  { "Source/destination not found.",
    "Source/destination not found.",
    "VERR_IPC_PROCESS_NOT_FOUND",
     VERR_IPC_PROCESS_NOT_FOUND }, 
  { "Receive timeout.",
    "Receive timeout.",
    "VERR_IPC_RECEIVE_TIMEOUT",
     VERR_IPC_RECEIVE_TIMEOUT }, 
  { "Send timeout.",
    "Send timeout.",
    "VERR_IPC_SEND_TIMEOUT",
     VERR_IPC_SEND_TIMEOUT }, 
  { "Receive cancelled.",
    "Receive cancelled.",
    "VERR_IPC_RECEIVE_CANCELLED",
     VERR_IPC_RECEIVE_CANCELLED }, 
  { "Send cancelled.",
    "Send cancelled.",
    "VERR_IPC_SEND_CANCELLED",
     VERR_IPC_SEND_CANCELLED }, 
  { "Receive aborted.",
    "Receive aborted.",
    "VERR_IPC_RECEIVE_ABORTED",
     VERR_IPC_RECEIVE_ABORTED }, 
  { "Send aborted.",
    "Send aborted.",
    "VERR_IPC_SEND_ABORTED",
     VERR_IPC_SEND_ABORTED }, 
  { "Couldn't map pages during receive.",
    "Couldn't map pages during receive.",
    "VERR_IPC_RECEIVE_MAP_FAILED",
     VERR_IPC_RECEIVE_MAP_FAILED }, 
  { "Couldn't map pages during send.",
    "Couldn't map pages during send.",
    "VERR_IPC_SEND_MAP_FAILED",
     VERR_IPC_SEND_MAP_FAILED }, 
  { "Send pagefault timeout in receive.",
    "Send pagefault timeout in receive.",
    "VERR_IPC_RECEIVE_SEND_PF_TIMEOUT",
     VERR_IPC_RECEIVE_SEND_PF_TIMEOUT }, 
  { "Send pagefault timeout in send.",
    "Send pagefault timeout in send.",
    "VERR_IPC_SEND_SEND_PF_TIMEOUT",
     VERR_IPC_SEND_SEND_PF_TIMEOUT }, 
  { "(One) receive buffer was too small, or too few buffers.",
    "(One) receive buffer was too small, or too few buffers.",
    "VINF_IPC_RECEIVE_MSG_CUT",
     VINF_IPC_RECEIVE_MSG_CUT }, 
  { "(One) send buffer was too small, or too few buffers.",
    "(One) send buffer was too small, or too few buffers.",
    "VINF_IPC_SEND_MSG_CUT",
     VINF_IPC_SEND_MSG_CUT }, 
  { "Dataspace manager server not found.",
    "Dataspace manager server not found.",
    "VERR_L4_DS_MANAGER_NOT_FOUND",
     VERR_L4_DS_MANAGER_NOT_FOUND }, 
  { "Invalid executable signature.",
    "Invalid executable signature.",
    "VERR_INVALID_EXE_SIGNATURE",
     VERR_INVALID_EXE_SIGNATURE }, 
  { "The iprt loader recognized a ELF image, but doesn't support loading it.",
    "The iprt loader recognized a ELF image, but doesn't support loading it.",
    "VERR_ELF_EXE_NOT_SUPPORTED",
     VERR_ELF_EXE_NOT_SUPPORTED }, 
  { "The iprt loader recognized a PE image, but doesn't support loading it.",
    "The iprt loader recognized a PE image, but doesn't support loading it.",
    "VERR_PE_EXE_NOT_SUPPORTED",
     VERR_PE_EXE_NOT_SUPPORTED }, 
  { "The iprt loader recognized a LX image, but doesn't support loading it.",
    "The iprt loader recognized a LX image, but doesn't support loading it.",
    "VERR_LX_EXE_NOT_SUPPORTED",
     VERR_LX_EXE_NOT_SUPPORTED }, 
  { "The iprt loader recognized a LE image, but doesn't support loading it.",
    "The iprt loader recognized a LE image, but doesn't support loading it.",
    "VERR_LE_EXE_NOT_SUPPORTED",
     VERR_LE_EXE_NOT_SUPPORTED }, 
  { "The iprt loader recognized a NE image, but doesn't support loading it.",
    "The iprt loader recognized a NE image, but doesn't support loading it.",
    "VERR_NE_EXE_NOT_SUPPORTED",
     VERR_NE_EXE_NOT_SUPPORTED }, 
  { "The iprt loader recognized a MZ image, but doesn't support loading it.",
    "The iprt loader recognized a MZ image, but doesn't support loading it.",
    "VERR_MZ_EXE_NOT_SUPPORTED",
     VERR_MZ_EXE_NOT_SUPPORTED }, 
  { "The iprt loader recognized an a.",
    "The iprt loader recognized an a.out image, but doesn't support loading it.",
    "VERR_AOUT_EXE_NOT_SUPPORTED",
     VERR_AOUT_EXE_NOT_SUPPORTED }, 
  { "Bad executable.",
    "Bad executable.",
    "VERR_BAD_EXE_FORMAT",
     VERR_BAD_EXE_FORMAT }, 
  { "Symbol (export) not found.",
    "Symbol (export) not found.",
    "VERR_SYMBOL_NOT_FOUND",
     VERR_SYMBOL_NOT_FOUND }, 
  { "Module not found.",
    "Module not found.",
    "VERR_MODULE_NOT_FOUND",
     VERR_MODULE_NOT_FOUND }, 
  { "The loader resolved an external symbol to an address to big for the image format.",
    "The loader resolved an external symbol to an address to big for the image format.",
    "VERR_SYMBOL_VALUE_TOO_BIG",
     VERR_SYMBOL_VALUE_TOO_BIG }, 
  { "The image is too big.",
    "The image is too big.",
    "VERR_IMAGE_TOO_BIG",
     VERR_IMAGE_TOO_BIG }, 
  { "The image base address is to high for this image type.",
    "The image base address is to high for this image type.",
    "VERR_IMAGE_BASE_TOO_HIGH",
     VERR_IMAGE_BASE_TOO_HIGH }, 
  { "Mismatching architecture.",
    "Mismatching architecture.",
    "VERR_LDR_ARCH_MISMATCH",
     VERR_LDR_ARCH_MISMATCH }, 
  { "Mismatch between IPRT and native loader.",
    "Mismatch between IPRT and native loader.",
    "VERR_LDR_MISMATCH_NATIVE",
     VERR_LDR_MISMATCH_NATIVE }, 
  { "Failed to resolve an imported (external) symbol.",
    "Failed to resolve an imported (external) symbol.",
    "VERR_LDR_IMPORTED_SYMBOL_NOT_FOUND",
     VERR_LDR_IMPORTED_SYMBOL_NOT_FOUND }, 
  { "Generic loader failure.",
    "Generic loader failure.",
    "VERR_LDR_GENERAL_FAILURE",
     VERR_LDR_GENERAL_FAILURE }, 
  { "Code signing error.",
    "Code signing error.",
    "VERR_LDR_IMAGE_HASH",
     VERR_LDR_IMAGE_HASH }, 
  { "The PE loader encountered delayed imports, a feature which hasn't been implemented yet.",
    "The PE loader encountered delayed imports, a feature which hasn't been implemented yet.",
    "VERR_LDRPE_DELAY_IMPORT",
     VERR_LDRPE_DELAY_IMPORT }, 
  { "The PE loader encountered a malformed certificate.",
    "The PE loader encountered a malformed certificate.",
    "VERR_LDRPE_CERT_MALFORMED",
     VERR_LDRPE_CERT_MALFORMED }, 
  { "The PE loader encountered a certificate with an unsupported type or structure revision.",
    "The PE loader encountered a certificate with an unsupported type or structure revision.",
    "VERR_LDRPE_CERT_UNSUPPORTED",
     VERR_LDRPE_CERT_UNSUPPORTED }, 
  { "The PE loader doesn't know how to deal with the global pointer data directory entry yet.",
    "The PE loader doesn't know how to deal with the global pointer data directory entry yet.",
    "VERR_LDRPE_GLOBALPTR",
     VERR_LDRPE_GLOBALPTR }, 
  { "The PE loader doesn't support the TLS data directory yet.",
    "The PE loader doesn't support the TLS data directory yet.",
    "VERR_LDRPE_TLS",
     VERR_LDRPE_TLS }, 
  { "The PE loader doesn't grok the COM descriptor data directory entry.",
    "The PE loader doesn't grok the COM descriptor data directory entry.",
    "VERR_LDRPE_COM_DESCRIPTOR",
     VERR_LDRPE_COM_DESCRIPTOR }, 
  { "The PE loader encountered an unknown load config directory/header size.",
    "The PE loader encountered an unknown load config directory/header size.",
    "VERR_LDRPE_LOAD_CONFIG_SIZE",
     VERR_LDRPE_LOAD_CONFIG_SIZE }, 
  { "The PE loader encountered a lock prefix table, a feature which hasn't been implemented yet.",
    "The PE loader encountered a lock prefix table, a feature which hasn't been implemented yet.",
    "VERR_LDRPE_LOCK_PREFIX_TABLE",
     VERR_LDRPE_LOCK_PREFIX_TABLE }, 
  { "The ELF loader doesn't handle foreign endianness.",
    "The ELF loader doesn't handle foreign endianness.",
    "VERR_LDRELF_ODD_ENDIAN",
     VERR_LDRELF_ODD_ENDIAN }, 
  { "The ELF image is 'dynamic', the ELF loader can only deal with 'relocatable' images at present.",
    "The ELF image is 'dynamic', the ELF loader can only deal with 'relocatable' images at present.",
    "VERR_LDRELF_DYN",
     VERR_LDRELF_DYN }, 
  { "The ELF image is 'executable', the ELF loader can only deal with 'relocatable' images at present.",
    "The ELF image is 'executable', the ELF loader can only deal with 'relocatable' images at present.",
    "VERR_LDRELF_EXEC",
     VERR_LDRELF_EXEC }, 
  { "The ELF image was created for an unsupported target machine type.",
    "The ELF image was created for an unsupported target machine type.",
    "VERR_LDRELF_MACHINE",
     VERR_LDRELF_MACHINE }, 
  { "The ELF version is not supported.",
    "The ELF version is not supported.",
    "VERR_LDRELF_VERSION",
     VERR_LDRELF_VERSION }, 
  { "The ELF loader cannot handle multiple SYMTAB sections.",
    "The ELF loader cannot handle multiple SYMTAB sections.",
    "VERR_LDRELF_MULTIPLE_SYMTABS",
     VERR_LDRELF_MULTIPLE_SYMTABS }, 
  { "The ELF loader encountered a relocation type which is not implemented.",
    "The ELF loader encountered a relocation type which is not implemented.",
    "VERR_LDRELF_RELOCATION_NOT_SUPPORTED",
     VERR_LDRELF_RELOCATION_NOT_SUPPORTED }, 
  { "The ELF loader encountered a bad symbol index.",
    "The ELF loader encountered a bad symbol index.",
    "VERR_LDRELF_INVALID_SYMBOL_INDEX",
     VERR_LDRELF_INVALID_SYMBOL_INDEX }, 
  { "The ELF loader encountered an invalid symbol name offset.",
    "The ELF loader encountered an invalid symbol name offset.",
    "VERR_LDRELF_INVALID_SYMBOL_NAME_OFFSET",
     VERR_LDRELF_INVALID_SYMBOL_NAME_OFFSET }, 
  { "The ELF loader encountered an invalid relocation offset.",
    "The ELF loader encountered an invalid relocation offset.",
    "VERR_LDRELF_INVALID_RELOCATION_OFFSET",
     VERR_LDRELF_INVALID_RELOCATION_OFFSET }, 
  { "The ELF loader didn't find the symbol/string table for the image.",
    "The ELF loader didn't find the symbol/string table for the image.",
    "VERR_LDRELF_NO_SYMBOL_OR_NO_STRING_TABS",
     VERR_LDRELF_NO_SYMBOL_OR_NO_STRING_TABS }, 
  { "The module contains no line number information.",
    "The module contains no line number information.",
    "VERR_DBG_NO_LINE_NUMBERS",
     VERR_DBG_NO_LINE_NUMBERS }, 
  { "The module contains no symbol information.",
    "The module contains no symbol information.",
    "VERR_DBG_NO_SYMBOLS",
     VERR_DBG_NO_SYMBOLS }, 
  { "The specified segment:offset address was invalid.",
    "The specified segment:offset address was invalid. Typically an attempt at addressing outside the segment boundary.",
    "VERR_DBG_INVALID_ADDRESS",
     VERR_DBG_INVALID_ADDRESS }, 
  { "Invalid segment index.",
    "Invalid segment index.",
    "VERR_DBG_INVALID_SEGMENT_INDEX",
     VERR_DBG_INVALID_SEGMENT_INDEX }, 
  { "Invalid segment offset.",
    "Invalid segment offset.",
    "VERR_DBG_INVALID_SEGMENT_OFFSET",
     VERR_DBG_INVALID_SEGMENT_OFFSET }, 
  { "Invalid image relative virtual address.",
    "Invalid image relative virtual address.",
    "VERR_DBG_INVALID_RVA",
     VERR_DBG_INVALID_RVA }, 
  { "Invalid image relative virtual address.",
    "Invalid image relative virtual address.",
    "VERR_DBG_SPECIAL_SEGMENT",
     VERR_DBG_SPECIAL_SEGMENT }, 
  { "Address conflict within a module/segment.",
    "Address conflict within a module/segment. Attempted to add a segment, symbol or line number that fully or partially overlaps with an existing one.",
    "VERR_DBG_ADDRESS_CONFLICT",
     VERR_DBG_ADDRESS_CONFLICT }, 
  { "Duplicate symbol within the module.",
    "Duplicate symbol within the module. Attempted to add a symbol which name already exists within the module.",
    "VERR_DBG_DUPLICATE_SYMBOL",
     VERR_DBG_DUPLICATE_SYMBOL }, 
  { "The segment index specified when adding a new segment is already in use.",
    "The segment index specified when adding a new segment is already in use.",
    "VERR_DBG_SEGMENT_INDEX_CONFLICT",
     VERR_DBG_SEGMENT_INDEX_CONFLICT }, 
  { "No line number was found for the specified address/ordinal/whatever.",
    "No line number was found for the specified address/ordinal/whatever.",
    "VERR_DBG_LINE_NOT_FOUND",
     VERR_DBG_LINE_NOT_FOUND }, 
  { "The length of the symbol name is out of range.",
    "The length of the symbol name is out of range. This means it is an empty string or that it's greater or equal to RTDBG_SYMBOL_NAME_LENGTH.",
    "VERR_DBG_SYMBOL_NAME_OUT_OF_RANGE",
     VERR_DBG_SYMBOL_NAME_OUT_OF_RANGE }, 
  { "The length of the file name is out of range.",
    "The length of the file name is out of range. This means it is an empty string or that it's greater or equal to RTDBG_FILE_NAME_LENGTH.",
    "VERR_DBG_FILE_NAME_OUT_OF_RANGE",
     VERR_DBG_FILE_NAME_OUT_OF_RANGE }, 
  { "The length of the segment name is out of range.",
    "The length of the segment name is out of range. This means it is an empty string or that it is greater or equal to RTDBG_SEGMENT_NAME_LENGTH.",
    "VERR_DBG_SEGMENT_NAME_OUT_OF_RANGE",
     VERR_DBG_SEGMENT_NAME_OUT_OF_RANGE }, 
  { "The specified address range wraps around.",
    "The specified address range wraps around.",
    "VERR_DBG_ADDRESS_WRAP",
     VERR_DBG_ADDRESS_WRAP }, 
  { "The file is not a valid NM map file.",
    "The file is not a valid NM map file.",
    "VERR_DBG_NOT_NM_MAP_FILE",
     VERR_DBG_NOT_NM_MAP_FILE }, 
  { "The file is not a valid /proc/kallsyms file.",
    "The file is not a valid /proc/kallsyms file.",
    "VERR_DBG_NOT_LINUX_KALLSYMS",
     VERR_DBG_NOT_LINUX_KALLSYMS }, 
  { "No debug module interpreter matching the debug info.",
    "No debug module interpreter matching the debug info.",
    "VERR_DBG_NO_MATCHING_INTERPRETER",
     VERR_DBG_NO_MATCHING_INTERPRETER }, 
  { "Invalid RT request type.",
    "Invalid RT request type. For the RTReqAlloc() case, the caller just specified an illegal enmType. For all the other occurrences it means indicates corruption, broken logic, or stupid interface user.",
    "VERR_RT_REQUEST_INVALID_TYPE",
     VERR_RT_REQUEST_INVALID_TYPE }, 
  { "Invalid RT request state.",
    "Invalid RT request state. The state of the request packet was not the expected and accepted one(s). Either the interface user screwed up, or we've got corruption/broken logic.",
    "VERR_RT_REQUEST_STATE",
     VERR_RT_REQUEST_STATE }, 
  { "Invalid RT request packet.",
    "Invalid RT request packet. One or more of the RT controlled packet members didn't contain the correct values. Some thing's broken.",
    "VERR_RT_REQUEST_INVALID_PACKAGE",
     VERR_RT_REQUEST_INVALID_PACKAGE }, 
  { "The status field has not been updated yet as the request is still pending completion.",
    "The status field has not been updated yet as the request is still pending completion. Someone queried the iStatus field before the request has been fully processed.",
    "VERR_RT_REQUEST_STATUS_STILL_PENDING",
     VERR_RT_REQUEST_STATUS_STILL_PENDING }, 
  { "The request has been freed, don't read the status now.",
    "The request has been freed, don't read the status now. Someone is reading the iStatus field of a freed request packet.",
    "VERR_RT_REQUEST_STATUS_FREED",
     VERR_RT_REQUEST_STATUS_FREED }, 
  { "The specified environment variable was not found.",
    "The specified environment variable was not found. (RTEnvGetEx).",
    "VERR_ENV_VAR_NOT_FOUND",
     VERR_ENV_VAR_NOT_FOUND }, 
  { "The specified environment variable was not found.",
    "The specified environment variable was not found. (RTEnvUnsetEx).",
    "VINF_ENV_VAR_NOT_FOUND",
     VINF_ENV_VAR_NOT_FOUND }, 
  { "The specified cpu is offline.",
    "The specified cpu is offline.",
    "VERR_CPU_OFFLINE",
     VERR_CPU_OFFLINE }, 
  { "The specified cpu was not found.",
    "The specified cpu was not found.",
    "VERR_CPU_NOT_FOUND",
     VERR_CPU_NOT_FOUND }, 
  { "RTGetOpt: Command line option not recognized.",
    "RTGetOpt: Command line option not recognized.",
    "VERR_GETOPT_UNKNOWN_OPTION",
     VERR_GETOPT_UNKNOWN_OPTION }, 
  { "RTGetOpt: Command line option needs argument.",
    "RTGetOpt: Command line option needs argument.",
    "VERR_GETOPT_REQUIRED_ARGUMENT_MISSING",
     VERR_GETOPT_REQUIRED_ARGUMENT_MISSING }, 
  { "RTGetOpt: Command line option has argument with bad format.",
    "RTGetOpt: Command line option has argument with bad format.",
    "VERR_GETOPT_INVALID_ARGUMENT_FORMAT",
     VERR_GETOPT_INVALID_ARGUMENT_FORMAT }, 
  { "RTGetOpt: Not an option.",
    "RTGetOpt: Not an option.",
    "VINF_GETOPT_NOT_OPTION",
     VINF_GETOPT_NOT_OPTION }, 
  { "RTGetOpt: Command line option needs an index.",
    "RTGetOpt: Command line option needs an index.",
    "VERR_GETOPT_INDEX_MISSING",
     VERR_GETOPT_INDEX_MISSING }, 
  { "RTCache: cache is full.",
    "RTCache: cache is full.",
    "VERR_CACHE_FULL",
     VERR_CACHE_FULL }, 
  { "RTCache: cache is empty.",
    "RTCache: cache is empty.",
    "VERR_CACHE_EMPTY",
     VERR_CACHE_EMPTY }, 
  { "Reached the max cache size.",
    "Reached the max cache size.",
    "VERR_MEM_CACHE_MAX_SIZE",
     VERR_MEM_CACHE_MAX_SIZE }, 
  { "Access denied error.",
    "Access denied error.",
    "VERR_S3_ACCESS_DENIED",
     VERR_S3_ACCESS_DENIED }, 
  { "The bucket/key wasn't found.",
    "The bucket/key wasn't found.",
    "VERR_S3_NOT_FOUND",
     VERR_S3_NOT_FOUND }, 
  { "Bucket already exists.",
    "Bucket already exists.",
    "VERR_S3_BUCKET_ALREADY_EXISTS",
     VERR_S3_BUCKET_ALREADY_EXISTS }, 
  { "Can't delete bucket with keys.",
    "Can't delete bucket with keys.",
    "VERR_S3_BUCKET_NOT_EMPTY",
     VERR_S3_BUCKET_NOT_EMPTY }, 
  { "The current operation was canceled.",
    "The current operation was canceled.",
    "VERR_S3_CANCELED",
     VERR_S3_CANCELED }, 
  { "A digest type used in the manifest file isn't supported.",
    "A digest type used in the manifest file isn't supported.",
    "VERR_MANIFEST_UNSUPPORTED_DIGEST_TYPE",
     VERR_MANIFEST_UNSUPPORTED_DIGEST_TYPE }, 
  { "An entry in the manifest file couldn't be interpreted correctly.",
    "An entry in the manifest file couldn't be interpreted correctly.",
    "VERR_MANIFEST_WRONG_FILE_FORMAT",
     VERR_MANIFEST_WRONG_FILE_FORMAT }, 
  { "A digest doesn't match the corresponding file.",
    "A digest doesn't match the corresponding file.",
    "VERR_MANIFEST_DIGEST_MISMATCH",
     VERR_MANIFEST_DIGEST_MISMATCH }, 
  { "The file list doesn't match to the content of the manifest file.",
    "The file list doesn't match to the content of the manifest file.",
    "VERR_MANIFEST_FILE_MISMATCH",
     VERR_MANIFEST_FILE_MISMATCH }, 
  { "The specified attribute (name) was not found in the manifest.",
    "The specified attribute (name) was not found in the manifest.",
    "VERR_MANIFEST_ATTR_NOT_FOUND",
     VERR_MANIFEST_ATTR_NOT_FOUND }, 
  { "The attribute type did not match.",
    "The attribute type did not match.",
    "VERR_MANIFEST_ATTR_TYPE_MISMATCH",
     VERR_MANIFEST_ATTR_TYPE_MISMATCH }, 
  { "No attribute of the specified types was found.",
    "No attribute of the specified types was found.",
    "VERR_MANIFEST_ATTR_TYPE_NOT_FOUND",
     VERR_MANIFEST_ATTR_TYPE_NOT_FOUND }, 
  { "The checksum of a tar header record doesn't match.",
    "The checksum of a tar header record doesn't match.",
    "VERR_TAR_CHKSUM_MISMATCH",
     VERR_TAR_CHKSUM_MISMATCH }, 
  { "The tar end of file record was read.",
    "The tar end of file record was read.",
    "VERR_TAR_END_OF_FILE",
     VERR_TAR_END_OF_FILE }, 
  { "The tar file ended unexpectedly.",
    "The tar file ended unexpectedly.",
    "VERR_TAR_UNEXPECTED_EOS",
     VERR_TAR_UNEXPECTED_EOS }, 
  { "The tar termination records was encountered without reaching the end of the input stream.",
    "The tar termination records was encountered without reaching the end of the input stream.",
    "VERR_TAR_EOS_MORE_INPUT",
     VERR_TAR_EOS_MORE_INPUT }, 
  { "A number tar header field was malformed.",
    "A number tar header field was malformed.",
    "VERR_TAR_BAD_NUM_FIELD",
     VERR_TAR_BAD_NUM_FIELD }, 
  { "A numeric tar header field was not terminated correctly.",
    "A numeric tar header field was not terminated correctly.",
    "VERR_TAR_BAD_NUM_FIELD_TERM",
     VERR_TAR_BAD_NUM_FIELD_TERM }, 
  { "A number tar header field was encoded using base-256 which this tar implementation currently does not support.",
    "A number tar header field was encoded using base-256 which this tar implementation currently does not support.",
    "VERR_TAR_BASE_256_NOT_SUPPORTED",
     VERR_TAR_BASE_256_NOT_SUPPORTED }, 
  { "A number tar header field yielded a value too large for the internal variable of the tar interpreter.",
    "A number tar header field yielded a value too large for the internal variable of the tar interpreter.",
    "VERR_TAR_NUM_VALUE_TOO_LARGE",
     VERR_TAR_NUM_VALUE_TOO_LARGE }, 
  { "The combined minor and major device number type is too small to hold the value stored in the tar header.",
    "The combined minor and major device number type is too small to hold the value stored in the tar header.",
    "VERR_TAR_DEV_VALUE_TOO_LARGE",
     VERR_TAR_DEV_VALUE_TOO_LARGE }, 
  { "The mode field in a tar header is bad.",
    "The mode field in a tar header is bad.",
    "VERR_TAR_BAD_MODE_FIELD",
     VERR_TAR_BAD_MODE_FIELD }, 
  { "The mode field should not include the type.",
    "The mode field should not include the type.",
    "VERR_TAR_MODE_WITH_TYPE",
     VERR_TAR_MODE_WITH_TYPE }, 
  { "The size field should be zero for links and symlinks.",
    "The size field should be zero for links and symlinks.",
    "VERR_TAR_SIZE_NOT_ZERO",
     VERR_TAR_SIZE_NOT_ZERO }, 
  { "Encountered an unknown type flag.",
    "Encountered an unknown type flag.",
    "VERR_TAR_UNKNOWN_TYPE_FLAG",
     VERR_TAR_UNKNOWN_TYPE_FLAG }, 
  { "The tar header is all zeros.",
    "The tar header is all zeros.",
    "VERR_TAR_ZERO_HEADER",
     VERR_TAR_ZERO_HEADER }, 
  { "Not a uniform standard tape v0.",
    "Not a uniform standard tape v0.0 archive header.",
    "VERR_TAR_NOT_USTAR_V00",
     VERR_TAR_NOT_USTAR_V00 }, 
  { "The name is empty.",
    "The name is empty.",
    "VERR_TAR_EMPTY_NAME",
     VERR_TAR_EMPTY_NAME }, 
  { "A non-directory entry has a name ending with a slash.",
    "A non-directory entry has a name ending with a slash.",
    "VERR_TAR_NON_DIR_ENDS_WITH_SLASH",
     VERR_TAR_NON_DIR_ENDS_WITH_SLASH }, 
  { "Encountered an unsupported portable archive exchange (pax) header.",
    "Encountered an unsupported portable archive exchange (pax) header.",
    "VERR_TAR_UNSUPPORTED_PAX_TYPE",
     VERR_TAR_UNSUPPORTED_PAX_TYPE }, 
  { "Encountered an unsupported Solaris Tar extension.",
    "Encountered an unsupported Solaris Tar extension.",
    "VERR_TAR_UNSUPPORTED_SOLARIS_HDR_TYPE",
     VERR_TAR_UNSUPPORTED_SOLARIS_HDR_TYPE }, 
  { "Encountered an unsupported GNU Tar extension.",
    "Encountered an unsupported GNU Tar extension.",
    "VERR_TAR_UNSUPPORTED_GNU_HDR_TYPE",
     VERR_TAR_UNSUPPORTED_GNU_HDR_TYPE }, 
  { "Malformed checksum field in the tar header.",
    "Malformed checksum field in the tar header.",
    "VERR_TAR_BAD_CHKSUM_FIELD",
     VERR_TAR_BAD_CHKSUM_FIELD }, 
  { "Malformed checksum field in the tar header.",
    "Malformed checksum field in the tar header.",
    "VERR_TAR_MALFORMED_GNU_LONGXXXX",
     VERR_TAR_MALFORMED_GNU_LONGXXXX }, 
  { "Too long name or link string.",
    "Too long name or link string.",
    "VERR_TAR_NAME_TOO_LONG",
     VERR_TAR_NAME_TOO_LONG }, 
  { "The handle is not pollable.",
    "The handle is not pollable.",
    "VERR_POLL_HANDLE_NOT_POLLABLE",
     VERR_POLL_HANDLE_NOT_POLLABLE }, 
  { "The handle ID is already present in the poll set.",
    "The handle ID is already present in the poll set.",
    "VERR_POLL_HANDLE_ID_EXISTS",
     VERR_POLL_HANDLE_ID_EXISTS }, 
  { "The handle ID was not found in the set.",
    "The handle ID was not found in the set.",
    "VERR_POLL_HANDLE_ID_NOT_FOUND",
     VERR_POLL_HANDLE_ID_NOT_FOUND }, 
  { "The poll set is full.",
    "The poll set is full.",
    "VERR_POLL_SET_IS_FULL",
     VERR_POLL_SET_IS_FULL }, 
  { "Generic zip error.",
    "Generic zip error.",
    "VERR_ZIP_ERROR",
     VERR_ZIP_ERROR }, 
  { "The compressed data was corrupted.",
    "The compressed data was corrupted.",
    "VERR_ZIP_CORRUPTED",
     VERR_ZIP_CORRUPTED }, 
  { "Ran out of memory while compressing or uncompressing.",
    "Ran out of memory while compressing or uncompressing.",
    "VERR_ZIP_NO_MEMORY",
     VERR_ZIP_NO_MEMORY }, 
  { "The compression format version is unsupported.",
    "The compression format version is unsupported.",
    "VERR_ZIP_UNSUPPORTED_VERSION",
     VERR_ZIP_UNSUPPORTED_VERSION }, 
  { "The compression method is unsupported.",
    "The compression method is unsupported.",
    "VERR_ZIP_UNSUPPORTED_METHOD",
     VERR_ZIP_UNSUPPORTED_METHOD }, 
  { "The compressed data started with a bad header.",
    "The compressed data started with a bad header.",
    "VERR_ZIP_BAD_HEADER",
     VERR_ZIP_BAD_HEADER }, 
  { "The VFS chain specification does not have a valid prefix.",
    "The VFS chain specification does not have a valid prefix.",
    "VERR_VFS_CHAIN_NO_PREFIX",
     VERR_VFS_CHAIN_NO_PREFIX }, 
  { "The VFS chain specification is empty.",
    "The VFS chain specification is empty.",
    "VERR_VFS_CHAIN_EMPTY",
     VERR_VFS_CHAIN_EMPTY }, 
  { "Expected an element.",
    "Expected an element.",
    "VERR_VFS_CHAIN_EXPECTED_ELEMENT",
     VERR_VFS_CHAIN_EXPECTED_ELEMENT }, 
  { "The VFS object type is not known.",
    "The VFS object type is not known.",
    "VERR_VFS_CHAIN_UNKNOWN_TYPE",
     VERR_VFS_CHAIN_UNKNOWN_TYPE }, 
  { "Expected a left paranthese.",
    "Expected a left paranthese.",
    "VERR_VFS_CHAIN_EXPECTED_LEFT_PARENTHESES",
     VERR_VFS_CHAIN_EXPECTED_LEFT_PARENTHESES }, 
  { "Expected a right paranthese.",
    "Expected a right paranthese.",
    "VERR_VFS_CHAIN_EXPECTED_RIGHT_PARENTHESES",
     VERR_VFS_CHAIN_EXPECTED_RIGHT_PARENTHESES }, 
  { "Expected a provider name.",
    "Expected a provider name.",
    "VERR_VFS_CHAIN_EXPECTED_PROVIDER_NAME",
     VERR_VFS_CHAIN_EXPECTED_PROVIDER_NAME }, 
  { "Expected an action (> or |).",
    "Expected an action (> or |).",
    "VERR_VFS_CHAIN_EXPECTED_ACTION",
     VERR_VFS_CHAIN_EXPECTED_ACTION }, 
  { "Only one action element is currently supported.",
    "Only one action element is currently supported.",
    "VERR_VFS_CHAIN_MULTIPLE_ACTIONS",
     VERR_VFS_CHAIN_MULTIPLE_ACTIONS }, 
  { "Expected to find a driving action (>), but there is none.",
    "Expected to find a driving action (>), but there is none.",
    "VERR_VFS_CHAIN_NO_ACTION",
     VERR_VFS_CHAIN_NO_ACTION }, 
  { "Expected pipe action.",
    "Expected pipe action.",
    "VERR_VFS_CHAIN_EXPECTED_PIPE",
     VERR_VFS_CHAIN_EXPECTED_PIPE }, 
  { "Unexpected action type.",
    "Unexpected action type.",
    "VERR_VFS_CHAIN_UNEXPECTED_ACTION_TYPE",
     VERR_VFS_CHAIN_UNEXPECTED_ACTION_TYPE }, 
  { "The volume map doesn't contain any valid volume.",
    "The volume map doesn't contain any valid volume.",
    "VERR_DVM_MAP_EMPTY",
     VERR_DVM_MAP_EMPTY }, 
  { "There is no volume behind the current one.",
    "There is no volume behind the current one.",
    "VERR_DVM_MAP_NO_VOLUME",
     VERR_DVM_MAP_NO_VOLUME }, 
  { "The internal logger revision did not match.",
    "The internal logger revision did not match.",
    "VERR_LOG_REVISION_MISMATCH",
     VERR_LOG_REVISION_MISMATCH }, 
  { "Failed to allocate VM memory.",
    "Failed to allocate VM memory.",
    "VERR_NO_VM_MEMORY",
     VERR_NO_VM_MEMORY }, 
  { "GC is toasted and the VMM should be terminated at once, but no need to panic about it :-).",
    "GC is toasted and the VMM should be terminated at once, but no need to panic about it :-).",
    "VERR_DONT_PANIC",
     VERR_DONT_PANIC }, 
  { "Unsupported CPU.",
    "Unsupported CPU.",
    "VERR_UNSUPPORTED_CPU",
     VERR_UNSUPPORTED_CPU }, 
  { "Unsupported CPU mode.",
    "Unsupported CPU mode.",
    "VERR_UNSUPPORTED_CPU_MODE",
     VERR_UNSUPPORTED_CPU_MODE }, 
  { "Page not present.",
    "Page not present.",
    "VERR_PAGE_NOT_PRESENT",
     VERR_PAGE_NOT_PRESENT }, 
  { "Invalid/Corrupted configuration file.",
    "Invalid/Corrupted configuration file.",
    "VERR_CFG_INVALID_FORMAT",
     VERR_CFG_INVALID_FORMAT }, 
  { "No configuration value exists.",
    "No configuration value exists.",
    "VERR_CFG_NO_VALUE",
     VERR_CFG_NO_VALUE }, 
  { "Selector not present.",
    "Selector not present.",
    "VERR_SELECTOR_NOT_PRESENT",
     VERR_SELECTOR_NOT_PRESENT }, 
  { "Not code selector.",
    "Not code selector.",
    "VERR_NOT_CODE_SELECTOR",
     VERR_NOT_CODE_SELECTOR }, 
  { "Not data selector.",
    "Not data selector.",
    "VERR_NOT_DATA_SELECTOR",
     VERR_NOT_DATA_SELECTOR }, 
  { "Out of selector bounds.",
    "Out of selector bounds.",
    "VERR_OUT_OF_SELECTOR_BOUNDS",
     VERR_OUT_OF_SELECTOR_BOUNDS }, 
  { "Invalid selector.",
    "Invalid selector. Usually beyond table limits.",
    "VERR_INVALID_SELECTOR",
     VERR_INVALID_SELECTOR }, 
  { "Invalid requested privilegde level.",
    "Invalid requested privilegde level.",
    "VERR_INVALID_RPL",
     VERR_INVALID_RPL }, 
  { "PML4 entry not present.",
    "PML4 entry not present.",
    "VERR_PAGE_MAP_LEVEL4_NOT_PRESENT",
     VERR_PAGE_MAP_LEVEL4_NOT_PRESENT }, 
  { "Page directory pointer not present.",
    "Page directory pointer not present.",
    "VERR_PAGE_DIRECTORY_PTR_NOT_PRESENT",
     VERR_PAGE_DIRECTORY_PTR_NOT_PRESENT }, 
  { "Raw mode doesn't support SMP.",
    "Raw mode doesn't support SMP.",
    "VERR_RAW_MODE_INVALID_SMP",
     VERR_RAW_MODE_INVALID_SMP }, 
  { "Invalid VM handle.",
    "Invalid VM handle.",
    "VERR_INVALID_VM_HANDLE",
     VERR_INVALID_VM_HANDLE }, 
  { "Invalid VM handle.",
    "Invalid VM handle.",
    "VERR_INVALID_VMCPU_HANDLE",
     VERR_INVALID_VMCPU_HANDLE }, 
  { "Invalid Virtual CPU ID.",
    "Invalid Virtual CPU ID.",
    "VERR_INVALID_CPU_ID",
     VERR_INVALID_CPU_ID }, 
  { "Too many VCPUs.",
    "Too many VCPUs.",
    "VERR_TOO_MANY_CPUS",
     VERR_TOO_MANY_CPUS }, 
  { "The service was disabled on the host.",
    "The service was disabled on the host. Returned by pfnInit in VBoxService to indicated a non-fatal error that should results in the particular service being disabled.",
    "VERR_SERVICE_DISABLED",
     VERR_SERVICE_DISABLED }, 
  { "First scheduling related status code.",
    "First scheduling related status code.",
    "VINF_EM_FIRST",
     VINF_EM_FIRST }, 
  { "Indicating that the VM is being terminated and that the the execution shall stop.",
    "Indicating that the VM is being terminated and that the the execution shall stop.",
    "VINF_EM_TERMINATE",
     VINF_EM_TERMINATE }, 
  { "Hypervisor code was stepped.",
    "Hypervisor code was stepped. EM will first send this to the debugger, and if the issue isn't resolved there it will enter guru meditation.",
    "VINF_EM_DBG_HYPER_STEPPED",
     VINF_EM_DBG_HYPER_STEPPED }, 
  { "Hit a breakpoint in the hypervisor code, EM will first send this to the debugger, and if the issue isn't resolved there it will enter guru meditation.",
    "Hit a breakpoint in the hypervisor code, EM will first send this to the debugger, and if the issue isn't resolved there it will enter guru meditation.",
    "VINF_EM_DBG_HYPER_BREAKPOINT",
     VINF_EM_DBG_HYPER_BREAKPOINT }, 
  { "Hit a possible assertion in the hypervisor code, EM will first send this to the debugger, and if the issue isn't resolved there it will enter guru meditation.",
    "Hit a possible assertion in the hypervisor code, EM will first send this to the debugger, and if the issue isn't resolved there it will enter guru meditation.",
    "VINF_EM_DBG_HYPER_ASSERTION",
     VINF_EM_DBG_HYPER_ASSERTION }, 
  { "Indicating that the VM should be suspended for debugging because the developer wants to inspect the VM state.",
    "Indicating that the VM should be suspended for debugging because the developer wants to inspect the VM state.",
    "VINF_EM_DBG_STOP",
     VINF_EM_DBG_STOP }, 
  { "Indicating success single stepping and that EM should report that event to the debugger.",
    "Indicating success single stepping and that EM should report that event to the debugger.",
    "VINF_EM_DBG_STEPPED",
     VINF_EM_DBG_STEPPED }, 
  { "Indicating that a breakpoint was hit and that EM should notify the debugger and in the event there is no debugger fail fatally.",
    "Indicating that a breakpoint was hit and that EM should notify the debugger and in the event there is no debugger fail fatally.",
    "VINF_EM_DBG_BREAKPOINT",
     VINF_EM_DBG_BREAKPOINT }, 
  { "Indicating that EM should single step an instruction.",
    "Indicating that EM should single step an instruction. The instruction is stepped in the current execution mode (RAW/REM).",
    "VINF_EM_DBG_STEP",
     VINF_EM_DBG_STEP }, 
  { "Indicating that the VM is being turned off and that the EM should exit to the VM awaiting the destruction request.",
    "Indicating that the VM is being turned off and that the EM should exit to the VM awaiting the destruction request.",
    "VINF_EM_OFF",
     VINF_EM_OFF }, 
  { "Indicating that the VM has been suspended and that the the thread should wait for request telling it what to do next.",
    "Indicating that the VM has been suspended and that the the thread should wait for request telling it what to do next.",
    "VINF_EM_SUSPEND",
     VINF_EM_SUSPEND }, 
  { "Indicating that the VM has been reset and that scheduling goes back to startup defaults.",
    "Indicating that the VM has been reset and that scheduling goes back to startup defaults.",
    "VINF_EM_RESET",
     VINF_EM_RESET }, 
  { "Indicating that the VM has executed a halt instruction and that the emulation thread should wait for an interrupt before resuming execution.",
    "Indicating that the VM has executed a halt instruction and that the emulation thread should wait for an interrupt before resuming execution.",
    "VINF_EM_HALT",
     VINF_EM_HALT }, 
  { "Indicating that the VM has been resumed and that the thread should start executing.",
    "Indicating that the VM has been resumed and that the thread should start executing.",
    "VINF_EM_RESUME",
     VINF_EM_RESUME }, 
  { "Indicating that we've got an out-of-memory condition and that we need to take the appropriate actions to deal with this.",
    "Indicating that we've got an out-of-memory condition and that we need to take the appropriate actions to deal with this. @remarks It might seem odd at first that this has lower priority than VINF_EM_HALT, VINF_EM_SUSPEND, and VINF_EM_RESUME. The reason is that these events are vital to correctly operating the VM. Also, they can't normally occur together with an out-of-memory condition, and even if that should happen the condition will be rediscovered before executing any more code.",
    "VINF_EM_NO_MEMORY",
     VINF_EM_NO_MEMORY }, 
  { "The fatal variant of VINF_EM_NO_MEMORY.",
    "The fatal variant of VINF_EM_NO_MEMORY.",
    "VERR_EM_NO_MEMORY",
     VERR_EM_NO_MEMORY }, 
  { "Indicating that a rescheduling to recompiled execution.",
    "Indicating that a rescheduling to recompiled execution. Typically caused by raw-mode executing code which is difficult/slow to virtualize rawly. @remarks Important to have a higher priority (lower number) than the other rescheduling status codes.",
    "VINF_EM_RESCHEDULE_REM",
     VINF_EM_RESCHEDULE_REM }, 
  { "Indicating that a rescheduling to vmx-mode execution.",
    "Indicating that a rescheduling to vmx-mode execution. Typically caused by REM detecting that hardware-accelerated raw-mode execution is possible.",
    "VINF_EM_RESCHEDULE_HWACC",
     VINF_EM_RESCHEDULE_HWACC }, 
  { "Indicating that a rescheduling to raw-mode execution.",
    "Indicating that a rescheduling to raw-mode execution. Typically caused by REM detecting that raw-mode execution is possible. @remarks Important to have a higher priority (lower number) than VINF_EM_RESCHEDULE.",
    "VINF_EM_RESCHEDULE_RAW",
     VINF_EM_RESCHEDULE_RAW }, 
  { "Indicating that a rescheduling now is required.",
    "Indicating that a rescheduling now is required. Typically caused by interrupts having changed the EIP.",
    "VINF_EM_RESCHEDULE",
     VINF_EM_RESCHEDULE }, 
  { "PARAV call.",
    "PARAV call.",
    "VINF_EM_RESCHEDULE_PARAV",
     VINF_EM_RESCHEDULE_PARAV }, 
  { "Go back into wait for SIPI mode.",
    "Go back into wait for SIPI mode.",
    "VINF_EM_WAIT_SIPI",
     VINF_EM_WAIT_SIPI }, 
  { "Last scheduling related status code.",
    "Last scheduling related status code. (inclusive).",
    "VINF_EM_LAST",
     VINF_EM_LAST }, 
  { "Reason for leaving GC: Guest trap which couldn't be handled in GC.",
    "Reason for leaving GC: Guest trap which couldn't be handled in GC. The trap is generally forwarded to the REM and executed there.",
    "VINF_EM_RAW_GUEST_TRAP",
     VINF_EM_RAW_GUEST_TRAP }, 
  { "Reason for leaving GC: Interrupted by external interrupt.",
    "Reason for leaving GC: Interrupted by external interrupt. The interrupt needed to be handled by the host OS.",
    "VINF_EM_RAW_INTERRUPT",
     VINF_EM_RAW_INTERRUPT }, 
  { "Reason for leaving GC: Interrupted by external interrupt while in hypervisor code.",
    "Reason for leaving GC: Interrupted by external interrupt while in hypervisor code. The interrupt needed to be handled by the host OS and hypervisor execution must be resumed. VM state is not complete at this point.",
    "VINF_EM_RAW_INTERRUPT_HYPER",
     VINF_EM_RAW_INTERRUPT_HYPER }, 
  { "Reason for leaving GC: A Ring switch was attempted.",
    "Reason for leaving GC: A Ring switch was attempted. Normal cause of action is to execute this in REM.",
    "VINF_EM_RAW_RING_SWITCH",
     VINF_EM_RAW_RING_SWITCH }, 
  { "Reason for leaving GC: A Ring switch was attempted using software interrupt.",
    "Reason for leaving GC: A Ring switch was attempted using software interrupt. Normal cause of action is to execute this in REM.",
    "VINF_EM_RAW_RING_SWITCH_INT",
     VINF_EM_RAW_RING_SWITCH_INT }, 
  { "Reason for leaving GC: A privileged instruction was attempted executed.",
    "Reason for leaving GC: A privileged instruction was attempted executed. Normal cause of action is to execute this in REM.",
    "VINF_EM_RAW_EXCEPTION_PRIVILEGED",
     VINF_EM_RAW_EXCEPTION_PRIVILEGED }, 
  { "Reason for leaving GC: Emulate instruction.",
    "Reason for leaving GC: Emulate instruction.",
    "VINF_EM_RAW_EMULATE_INSTR",
     VINF_EM_RAW_EMULATE_INSTR }, 
  { "Reason for leaving GC: Unhandled TSS write.",
    "Reason for leaving GC: Unhandled TSS write. Recompiler gets control.",
    "VINF_EM_RAW_EMULATE_INSTR_TSS_FAULT",
     VINF_EM_RAW_EMULATE_INSTR_TSS_FAULT }, 
  { "Reason for leaving GC: Unhandled LDT write.",
    "Reason for leaving GC: Unhandled LDT write. Recompiler gets control.",
    "VINF_EM_RAW_EMULATE_INSTR_LDT_FAULT",
     VINF_EM_RAW_EMULATE_INSTR_LDT_FAULT }, 
  { "Reason for leaving GC: Unhandled IDT write.",
    "Reason for leaving GC: Unhandled IDT write. Recompiler gets control.",
    "VINF_EM_RAW_EMULATE_INSTR_IDT_FAULT",
     VINF_EM_RAW_EMULATE_INSTR_IDT_FAULT }, 
  { "Reason for leaving GC: Unhandled GDT write.",
    "Reason for leaving GC: Unhandled GDT write. Recompiler gets control.",
    "VINF_EM_RAW_EMULATE_INSTR_GDT_FAULT",
     VINF_EM_RAW_EMULATE_INSTR_GDT_FAULT }, 
  { "Reason for leaving GC: Unhandled Page Directory write.",
    "Reason for leaving GC: Unhandled Page Directory write. Recompiler gets control.",
    "VINF_EM_RAW_EMULATE_INSTR_PD_FAULT",
     VINF_EM_RAW_EMULATE_INSTR_PD_FAULT }, 
  { "Reason for leaving GC: jump inside generated patch jump.",
    "Reason for leaving GC: jump inside generated patch jump. Fatal error.",
    "VERR_EM_RAW_PATCH_CONFLICT",
     VERR_EM_RAW_PATCH_CONFLICT }, 
  { "Reason for leaving GC: Hlt instruction.",
    "Reason for leaving GC: Hlt instruction. Recompiler gets control.",
    "VINF_EM_RAW_EMULATE_INSTR_HLT",
     VINF_EM_RAW_EMULATE_INSTR_HLT }, 
  { "Reason for leaving GC: Ring-3 operation pending.",
    "Reason for leaving GC: Ring-3 operation pending.",
    "VINF_EM_RAW_TO_R3",
     VINF_EM_RAW_TO_R3 }, 
  { "Reason for leaving GC: Timer pending.",
    "Reason for leaving GC: Timer pending.",
    "VINF_EM_RAW_TIMER_PENDING",
     VINF_EM_RAW_TIMER_PENDING }, 
  { "Reason for leaving GC: Interrupt pending (guest).",
    "Reason for leaving GC: Interrupt pending (guest).",
    "VINF_EM_RAW_INTERRUPT_PENDING",
     VINF_EM_RAW_INTERRUPT_PENDING }, 
  { "Reason for leaving GC: Encountered a stale selector.",
    "Reason for leaving GC: Encountered a stale selector.",
    "VINF_EM_RAW_STALE_SELECTOR",
     VINF_EM_RAW_STALE_SELECTOR }, 
  { "Reason for leaving GC: The IRET resuming guest code trapped.",
    "Reason for leaving GC: The IRET resuming guest code trapped.",
    "VINF_EM_RAW_IRET_TRAP",
     VINF_EM_RAW_IRET_TRAP }, 
  { "Reason for leaving GC: Emulate (MM)IO intensive code in the recompiler.",
    "Reason for leaving GC: Emulate (MM)IO intensive code in the recompiler.",
    "VINF_EM_RAW_EMULATE_IO_BLOCK",
     VINF_EM_RAW_EMULATE_IO_BLOCK }, 
  { "The interpreter was unable to deal with the instruction at hand.",
    "The interpreter was unable to deal with the instruction at hand.",
    "VERR_EM_INTERPRETER",
     VERR_EM_INTERPRETER }, 
  { "Internal EM error caused by an unknown warning or informational status code.",
    "Internal EM error caused by an unknown warning or informational status code.",
    "VERR_EM_INTERNAL_ERROR",
     VERR_EM_INTERNAL_ERROR }, 
  { "Pending VM request packet.",
    "Pending VM request packet.",
    "VINF_EM_PENDING_REQUEST",
     VINF_EM_PENDING_REQUEST }, 
  { "Start instruction stepping (debug only).",
    "Start instruction stepping (debug only).",
    "VINF_EM_RAW_EMULATE_DBG_STEP",
     VINF_EM_RAW_EMULATE_DBG_STEP }, 
  { "Patch TPR access instruction.",
    "Patch TPR access instruction.",
    "VINF_EM_HWACCM_PATCH_TPR_INSTR",
     VINF_EM_HWACCM_PATCH_TPR_INSTR }, 
  { "The EMInterpretDisasOne / EMInterpretDisasOneEx methods failed to disassemble the instruction.",
    "The EMInterpretDisasOne / EMInterpretDisasOneEx methods failed to disassemble the instruction.",
    "VERR_EM_INTERNAL_DISAS_ERROR",
     VERR_EM_INTERNAL_DISAS_ERROR }, 
  { "Unexpected guest mapping conflict detected.",
    "Unexpected guest mapping conflict detected.",
    "VERR_EM_UNEXPECTED_MAPPING_CONFLICT",
     VERR_EM_UNEXPECTED_MAPPING_CONFLICT }, 
  { "The function called requires the caller to be attached as a debugger to the VM.",
    "The function called requires the caller to be attached as a debugger to the VM.",
    "VERR_DBGF_NOT_ATTACHED",
     VERR_DBGF_NOT_ATTACHED }, 
  { "Someone (including the caller) was already attached as debugger to the VM.",
    "Someone (including the caller) was already attached as debugger to the VM.",
    "VERR_DBGF_ALREADY_ATTACHED",
     VERR_DBGF_ALREADY_ATTACHED }, 
  { "Tried to hald a debugger which was already halted.",
    "Tried to hald a debugger which was already halted. (This is a warning and not an error.).",
    "VWRN_DBGF_ALREADY_HALTED",
     VWRN_DBGF_ALREADY_HALTED }, 
  { "The DBGF has no more free breakpoint slots.",
    "The DBGF has no more free breakpoint slots.",
    "VERR_DBGF_NO_MORE_BP_SLOTS",
     VERR_DBGF_NO_MORE_BP_SLOTS }, 
  { "The DBGF couldn't find the specified breakpoint.",
    "The DBGF couldn't find the specified breakpoint.",
    "VERR_DBGF_BP_NOT_FOUND",
     VERR_DBGF_BP_NOT_FOUND }, 
  { "Attempted to enabled a breakpoint which was already enabled.",
    "Attempted to enabled a breakpoint which was already enabled.",
    "VINF_DBGF_BP_ALREADY_ENABLED",
     VINF_DBGF_BP_ALREADY_ENABLED }, 
  { "Attempted to disabled a breakpoint which was already disabled.",
    "Attempted to disabled a breakpoint which was already disabled.",
    "VINF_DBGF_BP_ALREADY_DISABLED",
     VINF_DBGF_BP_ALREADY_DISABLED }, 
  { "The breakpoint already exists.",
    "The breakpoint already exists.",
    "VINF_DBGF_BP_ALREADY_EXIST",
     VINF_DBGF_BP_ALREADY_EXIST }, 
  { "The byte string was not found.",
    "The byte string was not found.",
    "VERR_DBGF_MEM_NOT_FOUND",
     VERR_DBGF_MEM_NOT_FOUND }, 
  { "The OS was not detected.",
    "The OS was not detected.",
    "VERR_DBGF_OS_NOT_DETCTED",
     VERR_DBGF_OS_NOT_DETCTED }, 
  { "The OS was not detected.",
    "The OS was not detected.",
    "VINF_DBGF_OS_NOT_DETCTED",
     VINF_DBGF_OS_NOT_DETCTED }, 
  { "The specified register was not found.",
    "The specified register was not found.",
    "VERR_DBGF_REGISTER_NOT_FOUND",
     VERR_DBGF_REGISTER_NOT_FOUND }, 
  { "The value was truncated to fit.",
    "The value was truncated to fit. For queries this means that the register is wider than the queried value. For setters this means that the value is wider than the register.",
    "VINF_DBGF_TRUNCATED_REGISTER",
     VINF_DBGF_TRUNCATED_REGISTER }, 
  { "The value was zero extended to fit.",
    "The value was zero extended to fit. For queries this means that the register is narrower than the queried value. For setters this means that the value is narrower than the register.",
    "VINF_DBGF_ZERO_EXTENDED_REGISTER",
     VINF_DBGF_ZERO_EXTENDED_REGISTER }, 
  { "The requested type conversion was not supported.",
    "The requested type conversion was not supported.",
    "VERR_DBGF_UNSUPPORTED_CAST",
     VERR_DBGF_UNSUPPORTED_CAST }, 
  { "The register is read-only and cannot be modified.",
    "The register is read-only and cannot be modified.",
    "VERR_DBGF_READ_ONLY_REGISTER",
     VERR_DBGF_READ_ONLY_REGISTER }, 
  { "Internal processing error #1 in the DBGF register code.",
    "Internal processing error #1 in the DBGF register code.",
    "VERR_DBGF_REG_IPE_1",
     VERR_DBGF_REG_IPE_1 }, 
  { "Internal processing error #2 in the DBGF register code.",
    "Internal processing error #2 in the DBGF register code.",
    "VERR_DBGF_REG_IPE_2",
     VERR_DBGF_REG_IPE_2 }, 
  { "Unhandled #DB in hypervisor code.",
    "Unhandled #DB in hypervisor code.",
    "VERR_DBGF_HYPER_DB_XCPT",
     VERR_DBGF_HYPER_DB_XCPT }, 
  { "Internal processing error #1 in the DBGF stack code.",
    "Internal processing error #1 in the DBGF stack code.",
    "VERR_DBGF_STACK_IPE_1",
     VERR_DBGF_STACK_IPE_1 }, 
  { "Internal processing error #2 in the DBGF stack code.",
    "Internal processing error #2 in the DBGF stack code.",
    "VERR_DBGF_STACK_IPE_2",
     VERR_DBGF_STACK_IPE_2 }, 
  { "Non fatal Patch Manager analysis phase warning.",
    "Non fatal Patch Manager analysis phase warning.",
    "VWRN_CONTINUE_ANALYSIS",
     VWRN_CONTINUE_ANALYSIS }, 
  { "Non fatal Patch Manager recompile phase warning (mapped to VWRN_CONTINUE_ANALYSIS).",
    "Non fatal Patch Manager recompile phase warning (mapped to VWRN_CONTINUE_ANALYSIS).",
    "VWRN_CONTINUE_RECOMPILE",
     VWRN_CONTINUE_RECOMPILE }, 
  { "Continue search (mapped to VWRN_CONTINUE_ANALYSIS).",
    "Continue search (mapped to VWRN_CONTINUE_ANALYSIS).",
    "VWRN_PATM_CONTINUE_SEARCH",
     VWRN_PATM_CONTINUE_SEARCH }, 
  { "Patch installation refused (patch too complex or unsupported instructions ).",
    "Patch installation refused (patch too complex or unsupported instructions ).",
    "VERR_PATCHING_REFUSED",
     VERR_PATCHING_REFUSED }, 
  { "Unable to find patch.",
    "Unable to find patch.",
    "VERR_PATCH_NOT_FOUND",
     VERR_PATCH_NOT_FOUND }, 
  { "Patch disabled.",
    "Patch disabled.",
    "VERR_PATCH_DISABLED",
     VERR_PATCH_DISABLED }, 
  { "Patch enabled.",
    "Patch enabled.",
    "VWRN_PATCH_ENABLED",
     VWRN_PATCH_ENABLED }, 
  { "Patch was already disabled.",
    "Patch was already disabled.",
    "VERR_PATCH_ALREADY_DISABLED",
     VERR_PATCH_ALREADY_DISABLED }, 
  { "Patch was already enabled.",
    "Patch was already enabled.",
    "VERR_PATCH_ALREADY_ENABLED",
     VERR_PATCH_ALREADY_ENABLED }, 
  { "Patch was removed.",
    "Patch was removed.",
    "VWRN_PATCH_REMOVED",
     VWRN_PATCH_REMOVED }, 
  { "Reason for leaving GC: #GP with EIP pointing to patch code.",
    "Reason for leaving GC: #GP with EIP pointing to patch code.",
    "VINF_PATM_PATCH_TRAP_GP",
     VINF_PATM_PATCH_TRAP_GP }, 
  { "First leave GC code.",
    "First leave GC code.",
    "VINF_PATM_LEAVEGC_FIRST",
     VINF_PATM_LEAVEGC_FIRST }, 
  { "Reason for leaving GC: #PF with EIP pointing to patch code.",
    "Reason for leaving GC: #PF with EIP pointing to patch code.",
    "VINF_PATM_PATCH_TRAP_PF",
     VINF_PATM_PATCH_TRAP_PF }, 
  { "Reason for leaving GC: int3 with EIP pointing to patch code.",
    "Reason for leaving GC: int3 with EIP pointing to patch code.",
    "VINF_PATM_PATCH_INT3",
     VINF_PATM_PATCH_INT3 }, 
  { "Reason for leaving GC: #PF for monitored patch page.",
    "Reason for leaving GC: #PF for monitored patch page.",
    "VINF_PATM_CHECK_PATCH_PAGE",
     VINF_PATM_CHECK_PATCH_PAGE }, 
  { "Reason for leaving GC: duplicate instruction called at current eip.",
    "Reason for leaving GC: duplicate instruction called at current eip.",
    "VINF_PATM_DUPLICATE_FUNCTION",
     VINF_PATM_DUPLICATE_FUNCTION }, 
  { "Execute one instruction with the recompiler.",
    "Execute one instruction with the recompiler.",
    "VINF_PATCH_EMULATE_INSTR",
     VINF_PATCH_EMULATE_INSTR }, 
  { "Reason for leaving GC: attempt to patch MMIO write.",
    "Reason for leaving GC: attempt to patch MMIO write.",
    "VINF_PATM_HC_MMIO_PATCH_WRITE",
     VINF_PATM_HC_MMIO_PATCH_WRITE }, 
  { "Reason for leaving GC: attempt to patch MMIO read.",
    "Reason for leaving GC: attempt to patch MMIO read.",
    "VINF_PATM_HC_MMIO_PATCH_READ",
     VINF_PATM_HC_MMIO_PATCH_READ }, 
  { "Reason for leaving GC: pending irq after iret that sets IF.",
    "Reason for leaving GC: pending irq after iret that sets IF.",
    "VINF_PATM_PENDING_IRQ_AFTER_IRET",
     VINF_PATM_PENDING_IRQ_AFTER_IRET }, 
  { "Last leave GC code.",
    "Last leave GC code.",
    "VINF_PATM_LEAVEGC_LAST",
     VINF_PATM_LEAVEGC_LAST }, 
  { "No conflicts to resolve.",
    "No conflicts to resolve.",
    "VERR_PATCH_NO_CONFLICT",
     VERR_PATCH_NO_CONFLICT }, 
  { "Detected unsafe code for patching.",
    "Detected unsafe code for patching.",
    "VERR_PATM_UNSAFE_CODE",
     VERR_PATM_UNSAFE_CODE }, 
  { "Terminate search branch.",
    "Terminate search branch.",
    "VWRN_PATCH_END_BRANCH",
     VWRN_PATCH_END_BRANCH }, 
  { "Already patched.",
    "Already patched.",
    "VERR_PATM_ALREADY_PATCHED",
     VERR_PATM_ALREADY_PATCHED }, 
  { "Spinlock detection failed.",
    "Spinlock detection failed.",
    "VINF_PATM_SPINLOCK_FAILED",
     VINF_PATM_SPINLOCK_FAILED }, 
  { "Continue execution after patch trap.",
    "Continue execution after patch trap.",
    "VINF_PATCH_CONTINUE",
     VINF_PATCH_CONTINUE }, 
  { "Trap not handled.",
    "Trap not handled.",
    "VWRN_CSAM_TRAP_NOT_HANDLED",
     VWRN_CSAM_TRAP_NOT_HANDLED }, 
  { "Patch installed.",
    "Patch installed.",
    "VWRN_CSAM_INSTRUCTION_PATCHED",
     VWRN_CSAM_INSTRUCTION_PATCHED }, 
  { "Page record not found.",
    "Page record not found.",
    "VWRN_CSAM_PAGE_NOT_FOUND",
     VWRN_CSAM_PAGE_NOT_FOUND }, 
  { "Reason for leaving GC: CSAM wants perform a task in ring-3.",
    "Reason for leaving GC: CSAM wants perform a task in ring-3.",
    "VINF_CSAM_PENDING_ACTION",
     VINF_CSAM_PENDING_ACTION }, 
  { "Attempt to create a GC mapping which conflicts with an existing mapping.",
    "Attempt to create a GC mapping which conflicts with an existing mapping.",
    "VERR_PGM_MAPPING_CONFLICT",
     VERR_PGM_MAPPING_CONFLICT }, 
  { "The physical handler range has no corresponding RAM range.",
    "The physical handler range has no corresponding RAM range. If this is MMIO, see todo above the return. If not MMIO, then it's someone else's fault...",
    "VERR_PGM_HANDLER_PHYSICAL_NO_RAM_RANGE",
     VERR_PGM_HANDLER_PHYSICAL_NO_RAM_RANGE }, 
  { "Attempt to register an access handler for a virtual range of which a part was already handled.",
    "Attempt to register an access handler for a virtual range of which a part was already handled.",
    "VERR_PGM_HANDLER_VIRTUAL_CONFLICT",
     VERR_PGM_HANDLER_VIRTUAL_CONFLICT }, 
  { "Attempt to register an access handler for a physical range of which a part was already handled.",
    "Attempt to register an access handler for a physical range of which a part was already handled.",
    "VERR_PGM_HANDLER_PHYSICAL_CONFLICT",
     VERR_PGM_HANDLER_PHYSICAL_CONFLICT }, 
  { "Invalid page directory specified to PGM.",
    "Invalid page directory specified to PGM.",
    "VERR_PGM_INVALID_PAGE_DIRECTORY",
     VERR_PGM_INVALID_PAGE_DIRECTORY }, 
  { "Invalid GC physical address.",
    "Invalid GC physical address.",
    "VERR_PGM_INVALID_GC_PHYSICAL_ADDRESS",
     VERR_PGM_INVALID_GC_PHYSICAL_ADDRESS }, 
  { "Invalid GC physical range.",
    "Invalid GC physical range. Usually used when a specified range crosses a RAM region boundary.",
    "VERR_PGM_INVALID_GC_PHYSICAL_RANGE",
     VERR_PGM_INVALID_GC_PHYSICAL_RANGE }, 
  { "Specified access handler was not found.",
    "Specified access handler was not found.",
    "VERR_PGM_HANDLER_NOT_FOUND",
     VERR_PGM_HANDLER_NOT_FOUND }, 
  { "Attempt to register a RAM range of which parts are already covered by existing RAM ranges.",
    "Attempt to register a RAM range of which parts are already covered by existing RAM ranges.",
    "VERR_PGM_RAM_CONFLICT",
     VERR_PGM_RAM_CONFLICT }, 
  { "Failed to add new mappings because the current mappings are fixed in guest os memory.",
    "Failed to add new mappings because the current mappings are fixed in guest os memory.",
    "VERR_PGM_MAPPINGS_FIXED",
     VERR_PGM_MAPPINGS_FIXED }, 
  { "Failed to fix mappings because of a conflict with the intermediate code.",
    "Failed to fix mappings because of a conflict with the intermediate code.",
    "VERR_PGM_MAPPINGS_FIX_CONFLICT",
     VERR_PGM_MAPPINGS_FIX_CONFLICT }, 
  { "Failed to fix mappings because a mapping rejected the address.",
    "Failed to fix mappings because a mapping rejected the address.",
    "VERR_PGM_MAPPINGS_FIX_REJECTED",
     VERR_PGM_MAPPINGS_FIX_REJECTED }, 
  { "Failed to fix mappings because the proposed memory area was to small.",
    "Failed to fix mappings because the proposed memory area was to small.",
    "VERR_PGM_MAPPINGS_FIX_TOO_SMALL",
     VERR_PGM_MAPPINGS_FIX_TOO_SMALL }, 
  { "Reason for leaving GC: The urge to syncing CR3.",
    "Reason for leaving GC: The urge to syncing CR3.",
    "VINF_PGM_SYNC_CR3",
     VINF_PGM_SYNC_CR3 }, 
  { "Page not marked for dirty bit tracking.",
    "Page not marked for dirty bit tracking.",
    "VINF_PGM_NO_DIRTY_BIT_TRACKING",
     VINF_PGM_NO_DIRTY_BIT_TRACKING }, 
  { "Page fault caused by dirty bit tracking; corrected.",
    "Page fault caused by dirty bit tracking; corrected.",
    "VINF_PGM_HANDLED_DIRTY_BIT_FAULT",
     VINF_PGM_HANDLED_DIRTY_BIT_FAULT }, 
  { "Go ahead with the default Read/Write operation.",
    "Go ahead with the default Read/Write operation. This is returned by a HC physical or virtual handler when it wants the PGMPhys[Read|Write] routine do the reading/writing.",
    "VINF_PGM_HANDLER_DO_DEFAULT",
     VINF_PGM_HANDLER_DO_DEFAULT }, 
  { "The paging mode of the host is not supported yet.",
    "The paging mode of the host is not supported yet.",
    "VERR_PGM_UNSUPPORTED_HOST_PAGING_MODE",
     VERR_PGM_UNSUPPORTED_HOST_PAGING_MODE }, 
  { "The physical guest page is a reserved/mmio page and does not have any HC address.",
    "The physical guest page is a reserved/mmio page and does not have any HC address.",
    "VERR_PGM_PHYS_PAGE_RESERVED",
     VERR_PGM_PHYS_PAGE_RESERVED }, 
  { "No page directory available for the hypervisor.",
    "No page directory available for the hypervisor.",
    "VERR_PGM_NO_HYPERVISOR_ADDRESS",
     VERR_PGM_NO_HYPERVISOR_ADDRESS }, 
  { "The shadow page pool was flushed.",
    "The shadow page pool was flushed. This means that a global CR3 sync was flagged. Anyone receiving this kind of status will have to get down to a SyncCR3 ASAP. See also VINF_PGM_SYNC_CR3.",
    "VERR_PGM_POOL_FLUSHED",
     VERR_PGM_POOL_FLUSHED }, 
  { "The shadow page pool was cleared.",
    "The shadow page pool was cleared. This is a error code internal to the shadow page pool, it will be converted to a VERR_PGM_POOL_FLUSHED before leaving the pool code.",
    "VERR_PGM_POOL_CLEARED",
     VERR_PGM_POOL_CLEARED }, 
  { "The returned shadow page is cached.",
    "The returned shadow page is cached.",
    "VINF_PGM_CACHED_PAGE",
     VINF_PGM_CACHED_PAGE }, 
  { "Returned by handler registration, modification and deregistration when the shadow PTs could be updated because the guest page aliased or/and mapped by multiple PTs.",
    "Returned by handler registration, modification and deregistration when the shadow PTs could be updated because the guest page aliased or/and mapped by multiple PTs.",
    "VINF_PGM_GCPHYS_ALIASED",
     VINF_PGM_GCPHYS_ALIASED }, 
  { "Reason for leaving GC: Paging mode changed.",
    "Reason for leaving GC: Paging mode changed. PGMChangeMode() uses this to force a switch to HC so it can safely deal with a mode switch.",
    "VINF_PGM_CHANGE_MODE",
     VINF_PGM_CHANGE_MODE }, 
  { "SyncPage modified the PDE.",
    "SyncPage modified the PDE. This is an internal status code used to communicate back to the #PF handler that the PDE was (probably) marked not-present and it should restart the instruction.",
    "VINF_PGM_SYNCPAGE_MODIFIED_PDE",
     VINF_PGM_SYNCPAGE_MODIFIED_PDE }, 
  { "Physical range crosses dynamic ram chunk boundary; translation to HC ptr not safe.",
    "Physical range crosses dynamic ram chunk boundary; translation to HC ptr not safe.",
    "VERR_PGM_GCPHYS_RANGE_CROSSES_BOUNDARY",
     VERR_PGM_GCPHYS_RANGE_CROSSES_BOUNDARY }, 
  { "Conflict between the core memory and the intermediate paging context, try again.",
    "Conflict between the core memory and the intermediate paging context, try again. There are some very special conditions applying to the intermediate paging context (used during the world switches), and some times we continuously run into these when asking the host kernel for memory during VM init. Let us know if you run into this and we'll adjust the code so it tries harder to avoid it.",
    "VERR_PGM_INTERMEDIATE_PAGING_CONFLICT",
     VERR_PGM_INTERMEDIATE_PAGING_CONFLICT }, 
  { "The shadow paging mode is not supported yet.",
    "The shadow paging mode is not supported yet.",
    "VERR_PGM_UNSUPPORTED_SHADOW_PAGING_MODE",
     VERR_PGM_UNSUPPORTED_SHADOW_PAGING_MODE }, 
  { "The dynamic mapping cache for physical memory failed.",
    "The dynamic mapping cache for physical memory failed.",
    "VERR_PGM_DYNMAP_FAILED",
     VERR_PGM_DYNMAP_FAILED }, 
  { "The auto usage cache for the dynamic mapping set is full.",
    "The auto usage cache for the dynamic mapping set is full.",
    "VERR_PGM_DYNMAP_FULL_SET",
     VERR_PGM_DYNMAP_FULL_SET }, 
  { "The initialization of the dynamic mapping cache failed.",
    "The initialization of the dynamic mapping cache failed.",
    "VERR_PGM_DYNMAP_SETUP_ERROR",
     VERR_PGM_DYNMAP_SETUP_ERROR }, 
  { "The expanding of the dynamic mapping cache failed.",
    "The expanding of the dynamic mapping cache failed.",
    "VERR_PGM_DYNMAP_EXPAND_ERROR",
     VERR_PGM_DYNMAP_EXPAND_ERROR }, 
  { "The page is unassigned (akin to VERR_PGM_INVALID_GC_PHYSICAL_ADDRESS).",
    "The page is unassigned (akin to VERR_PGM_INVALID_GC_PHYSICAL_ADDRESS).",
    "VERR_PGM_PHYS_TLB_UNASSIGNED",
     VERR_PGM_PHYS_TLB_UNASSIGNED }, 
  { "Catch any access and route it thru PGM.",
    "Catch any access and route it thru PGM.",
    "VERR_PGM_PHYS_TLB_CATCH_ALL",
     VERR_PGM_PHYS_TLB_CATCH_ALL }, 
  { "Catch write access and route it thru PGM.",
    "Catch write access and route it thru PGM.",
    "VINF_PGM_PHYS_TLB_CATCH_WRITE",
     VINF_PGM_PHYS_TLB_CATCH_WRITE }, 
  { "No CR3 root shadow page table..",
    "No CR3 root shadow page table..",
    "VERR_PGM_NO_CR3_SHADOW_ROOT",
     VERR_PGM_NO_CR3_SHADOW_ROOT }, 
  { "Trying to free a page with an invalid Page ID.",
    "Trying to free a page with an invalid Page ID.",
    "VERR_PGM_PHYS_INVALID_PAGE_ID",
     VERR_PGM_PHYS_INVALID_PAGE_ID }, 
  { "PGMPhysWrite/Read hit a handler in Ring-0 or raw-mode context.",
    "PGMPhysWrite/Read hit a handler in Ring-0 or raw-mode context.",
    "VERR_PGM_PHYS_WR_HIT_HANDLER",
     VERR_PGM_PHYS_WR_HIT_HANDLER }, 
  { "Trying to free a page that isn't RAM.",
    "Trying to free a page that isn't RAM.",
    "VERR_PGM_PHYS_NOT_RAM",
     VERR_PGM_PHYS_NOT_RAM }, 
  { "Not ROM page.",
    "Not ROM page.",
    "VERR_PGM_PHYS_NOT_ROM",
     VERR_PGM_PHYS_NOT_ROM }, 
  { "Not MMIO page.",
    "Not MMIO page.",
    "VERR_PGM_PHYS_NOT_MMIO",
     VERR_PGM_PHYS_NOT_MMIO }, 
  { "Not MMIO2 page.",
    "Not MMIO2 page.",
    "VERR_PGM_PHYS_NOT_MMIO2",
     VERR_PGM_PHYS_NOT_MMIO2 }, 
  { "Already aliased to a different page.",
    "Already aliased to a different page.",
    "VERR_PGM_HANDLER_ALREADY_ALIASED",
     VERR_PGM_HANDLER_ALREADY_ALIASED }, 
  { "Already aliased to the same page.",
    "Already aliased to the same page.",
    "VINF_PGM_HANDLER_ALREADY_ALIASED",
     VINF_PGM_HANDLER_ALREADY_ALIASED }, 
  { "PGM pool flush pending - return to ring 3.",
    "PGM pool flush pending - return to ring 3.",
    "VINF_PGM_POOL_FLUSH_PENDING",
     VINF_PGM_POOL_FLUSH_PENDING }, 
  { "Unable to use the range for a large page.",
    "Unable to use the range for a large page.",
    "VERR_PGM_INVALID_LARGE_PAGE_RANGE",
     VERR_PGM_INVALID_LARGE_PAGE_RANGE }, 
  { "Don't mess around with ballooned pages.",
    "Don't mess around with ballooned pages.",
    "VERR_PGM_PHYS_PAGE_BALLOONED",
     VERR_PGM_PHYS_PAGE_BALLOONED }, 
  { "pgmPhysPageMapCommon encountered PGMPAGETYPE_MMIO2_ALIAS_MMIO.",
    "pgmPhysPageMapCommon encountered PGMPAGETYPE_MMIO2_ALIAS_MMIO.",
    "VERR_PGM_MAP_MMIO2_ALIAS_MMIO",
     VERR_PGM_MAP_MMIO2_ALIAS_MMIO }, 
  { "Guest mappings are disabled.",
    "Guest mappings are disabled.",
    "VERR_PGM_MAPPINGS_DISABLED",
     VERR_PGM_MAPPINGS_DISABLED }, 
  { "No guest mappings when SMP is enabled.",
    "No guest mappings when SMP is enabled.",
    "VERR_PGM_MAPPINGS_SMP",
     VERR_PGM_MAPPINGS_SMP }, 
  { "Invalid saved page state.",
    "Invalid saved page state.",
    "VERR_PGM_INVALID_SAVED_PAGE_STATE",
     VERR_PGM_INVALID_SAVED_PAGE_STATE }, 
  { "Encountered an unexpected page type in the saved state.",
    "Encountered an unexpected page type in the saved state.",
    "VERR_PGM_LOAD_UNEXPECTED_PAGE_TYPE",
     VERR_PGM_LOAD_UNEXPECTED_PAGE_TYPE }, 
  { "Encountered an unexpected page state in the saved state.",
    "Encountered an unexpected page state in the saved state.",
    "VERR_PGM_UNEXPECTED_PAGE_STATE",
     VERR_PGM_UNEXPECTED_PAGE_STATE }, 
  { "Couldn't find MMIO2 range from saved state.",
    "Couldn't find MMIO2 range from saved state.",
    "VERR_PGM_SAVED_MMIO2_RANGE_NOT_FOUND",
     VERR_PGM_SAVED_MMIO2_RANGE_NOT_FOUND }, 
  { "Couldn't find MMIO2 page from saved state.",
    "Couldn't find MMIO2 page from saved state.",
    "VERR_PGM_SAVED_MMIO2_PAGE_NOT_FOUND",
     VERR_PGM_SAVED_MMIO2_PAGE_NOT_FOUND }, 
  { "Couldn't find ROM range from saved state.",
    "Couldn't find ROM range from saved state.",
    "VERR_PGM_SAVED_ROM_RANGE_NOT_FOUND",
     VERR_PGM_SAVED_ROM_RANGE_NOT_FOUND }, 
  { "Couldn't find ROM page from saved state.",
    "Couldn't find ROM page from saved state.",
    "VERR_PGM_SAVED_ROM_PAGE_NOT_FOUND",
     VERR_PGM_SAVED_ROM_PAGE_NOT_FOUND }, 
  { "ROM page mismatch between saved state and the VM.",
    "ROM page mismatch between saved state and the VM.",
    "VERR_PGM_SAVED_ROM_PAGE_PROT",
     VERR_PGM_SAVED_ROM_PAGE_PROT }, 
  { "Unknown saved state record.",
    "Unknown saved state record.",
    "VERR_PGM_SAVED_REC_TYPE",
     VERR_PGM_SAVED_REC_TYPE }, 
  { "Internal processing error in the PGM dynmap (r0/rc).",
    "Internal processing error in the PGM dynmap (r0/rc).",
    "VERR_PGM_DYNMAP_IPE",
     VERR_PGM_DYNMAP_IPE }, 
  { "Internal processing error in the PGM handy page allocator.",
    "Internal processing error in the PGM handy page allocator.",
    "VERR_PGM_HANDY_PAGE_IPE",
     VERR_PGM_HANDY_PAGE_IPE }, 
  { "Failed to map the guest PML4.",
    "Failed to map the guest PML4.",
    "VERR_PGM_PML4_MAPPING",
     VERR_PGM_PML4_MAPPING }, 
  { "Failed to obtain a pool page.",
    "Failed to obtain a pool page.",
    "VERR_PGM_POOL_GET_PAGE_FAILED",
     VERR_PGM_POOL_GET_PAGE_FAILED }, 
  { "A PGM function was called in a mode where it isn't supposed to be used.",
    "A PGM function was called in a mode where it isn't supposed to be used.",
    "VERR_PGM_NOT_USED_IN_MODE",
     VERR_PGM_NOT_USED_IN_MODE }, 
  { "The CR3 address specified memory we don't know about.",
    "The CR3 address specified memory we don't know about.",
    "VERR_PGM_INVALID_CR3_ADDR",
     VERR_PGM_INVALID_CR3_ADDR }, 
  { "One or the PDPEs specified memory we don't know about.",
    "One or the PDPEs specified memory we don't know about.",
    "VERR_PGM_INVALID_PDPE_ADDR",
     VERR_PGM_INVALID_PDPE_ADDR }, 
  { "Internal processing error in the PGM physical handler code.",
    "Internal processing error in the PGM physical handler code.",
    "VERR_PGM_PHYS_HANDLER_IPE",
     VERR_PGM_PHYS_HANDLER_IPE }, 
  { "Internal processing error #1 in the PGM physial page mapping code.",
    "Internal processing error #1 in the PGM physial page mapping code.",
    "VERR_PGM_PHYS_PAGE_MAP_IPE_1",
     VERR_PGM_PHYS_PAGE_MAP_IPE_1 }, 
  { "Internal processing error #2 in the PGM physial page mapping code.",
    "Internal processing error #2 in the PGM physial page mapping code.",
    "VERR_PGM_PHYS_PAGE_MAP_IPE_2",
     VERR_PGM_PHYS_PAGE_MAP_IPE_2 }, 
  { "Internal processing error #3 in the PGM physial page mapping code.",
    "Internal processing error #3 in the PGM physial page mapping code.",
    "VERR_PGM_PHYS_PAGE_MAP_IPE_3",
     VERR_PGM_PHYS_PAGE_MAP_IPE_3 }, 
  { "Internal processing error #4 in the PGM physial page mapping code.",
    "Internal processing error #4 in the PGM physial page mapping code.",
    "VERR_PGM_PHYS_PAGE_MAP_IPE_4",
     VERR_PGM_PHYS_PAGE_MAP_IPE_4 }, 
  { "Too many loops looking for a page to reuse.",
    "Too many loops looking for a page to reuse.",
    "VERR_PGM_POOL_TOO_MANY_LOOPS",
     VERR_PGM_POOL_TOO_MANY_LOOPS }, 
  { "Internal procesing error related to guest mappings.",
    "Internal procesing error related to guest mappings.",
    "VERR_PGM_MAPPING_IPE",
     VERR_PGM_MAPPING_IPE }, 
  { "An attempt was made to grow an already maxed out page pool.",
    "An attempt was made to grow an already maxed out page pool.",
    "VERR_PGM_POOL_MAXED_OUT_ALREADY",
     VERR_PGM_POOL_MAXED_OUT_ALREADY }, 
  { "Internal processing error in the page pool code.",
    "Internal processing error in the page pool code.",
    "VERR_PGM_POOL_IPE",
     VERR_PGM_POOL_IPE }, 
  { "The write monitor is already engaged.",
    "The write monitor is already engaged.",
    "VERR_PGM_WRITE_MONITOR_ENGAGED",
     VERR_PGM_WRITE_MONITOR_ENGAGED }, 
  { "Failed to get a guest page which is expected to be present.",
    "Failed to get a guest page which is expected to be present.",
    "VERR_PGM_PHYS_PAGE_GET_IPE",
     VERR_PGM_PHYS_PAGE_GET_IPE }, 
  { "We were given a NULL pPage parameter.",
    "We were given a NULL pPage parameter.",
    "VERR_PGM_PHYS_NULL_PAGE_PARAM",
     VERR_PGM_PHYS_NULL_PAGE_PARAM }, 
  { "PCI passthru is not supported by this build.",
    "PCI passthru is not supported by this build.",
    "VERR_PGM_PCI_PASSTHRU_MISCONFIG",
     VERR_PGM_PCI_PASSTHRU_MISCONFIG }, 
  { "Attempt to register a RAM range of which parts are already covered by existing RAM ranges.",
    "Attempt to register a RAM range of which parts are already covered by existing RAM ranges.",
    "VERR_MM_RAM_CONFLICT",
     VERR_MM_RAM_CONFLICT }, 
  { "Hypervisor memory allocation failed.",
    "Hypervisor memory allocation failed.",
    "VERR_MM_HYPER_NO_MEMORY",
     VERR_MM_HYPER_NO_MEMORY }, 
  { "A bad trap type ended up in mmGCRamTrap0eHandler.",
    "A bad trap type ended up in mmGCRamTrap0eHandler.",
    "VERR_MM_BAD_TRAP_TYPE_IPE",
     VERR_MM_BAD_TRAP_TYPE_IPE }, 
  { "The caller shall raise an #GP(0) exception.",
    "The caller shall raise an #GP(0) exception.",
    "VERR_CPUM_RAISE_GP_0",
     VERR_CPUM_RAISE_GP_0 }, 
  { "Incompatible CPUM configuration.",
    "Incompatible CPUM configuration.",
    "VERR_CPUM_INCOMPATIBLE_CONFIG",
     VERR_CPUM_INCOMPATIBLE_CONFIG }, 
  { "The specified data unit already exist.",
    "The specified data unit already exist.",
    "VERR_SSM_UNIT_EXISTS",
     VERR_SSM_UNIT_EXISTS }, 
  { "The specified data unit wasn't found.",
    "The specified data unit wasn't found.",
    "VERR_SSM_UNIT_NOT_FOUND",
     VERR_SSM_UNIT_NOT_FOUND }, 
  { "The specified data unit wasn't owned by caller.",
    "The specified data unit wasn't owned by caller.",
    "VERR_SSM_UNIT_NOT_OWNER",
     VERR_SSM_UNIT_NOT_OWNER }, 
  { "General saved state file integrity error.",
    "General saved state file integrity error.",
    "VERR_SSM_INTEGRITY",
     VERR_SSM_INTEGRITY }, 
  { "The saved state file magic was not recognized.",
    "The saved state file magic was not recognized.",
    "VERR_SSM_INTEGRITY_MAGIC",
     VERR_SSM_INTEGRITY_MAGIC }, 
  { "The saved state file version is not supported.",
    "The saved state file version is not supported.",
    "VERR_SSM_INTEGRITY_VERSION",
     VERR_SSM_INTEGRITY_VERSION }, 
  { "The saved state file size didn't match the one in the header.",
    "The saved state file size didn't match the one in the header.",
    "VERR_SSM_INTEGRITY_SIZE",
     VERR_SSM_INTEGRITY_SIZE }, 
  { "The CRC of the saved state file did not match.",
    "The CRC of the saved state file did not match.",
    "VERR_SSM_INTEGRITY_CRC",
     VERR_SSM_INTEGRITY_CRC }, 
  { "The machine uuid field wasn't null.",
    "The machine uuid field wasn't null.",
    "VERR_SMM_INTEGRITY_MACHINE",
     VERR_SMM_INTEGRITY_MACHINE }, 
  { "Saved state header integrity error.",
    "Saved state header integrity error.",
    "VERR_SSM_INTEGRITY_HEADER",
     VERR_SSM_INTEGRITY_HEADER }, 
  { "Unit header integrity error.",
    "Unit header integrity error.",
    "VERR_SSM_INTEGRITY_UNIT",
     VERR_SSM_INTEGRITY_UNIT }, 
  { "Invalid unit magic (internal data tag).",
    "Invalid unit magic (internal data tag).",
    "VERR_SSM_INTEGRITY_UNIT_MAGIC",
     VERR_SSM_INTEGRITY_UNIT_MAGIC }, 
  { "The file contained a data unit which no-one wants.",
    "The file contained a data unit which no-one wants.",
    "VERR_SSM_INTEGRITY_UNIT_NOT_FOUND",
     VERR_SSM_INTEGRITY_UNIT_NOT_FOUND }, 
  { "Incorrect version numbers in the header.",
    "Incorrect version numbers in the header.",
    "VERR_SSM_INTEGRITY_VBOX_VERSION",
     VERR_SSM_INTEGRITY_VBOX_VERSION }, 
  { "Footer integrity error.",
    "Footer integrity error.",
    "VERR_SSM_INTEGRITY_FOOTER",
     VERR_SSM_INTEGRITY_FOOTER }, 
  { "Record header integrity error.",
    "Record header integrity error.",
    "VERR_SSM_INTEGRITY_REC_HDR",
     VERR_SSM_INTEGRITY_REC_HDR }, 
  { "Termination record integrity error.",
    "Termination record integrity error.",
    "VERR_SSM_INTEGRITY_REC_TERM",
     VERR_SSM_INTEGRITY_REC_TERM }, 
  { "Termination record CRC mismatch.",
    "Termination record CRC mismatch.",
    "VERR_SSM_INTEGRITY_REC_TERM_CRC",
     VERR_SSM_INTEGRITY_REC_TERM_CRC }, 
  { "Decompression interity error.",
    "Decompression interity error.",
    "VERR_SSM_INTEGRITY_DECOMPRESSION",
     VERR_SSM_INTEGRITY_DECOMPRESSION }, 
  { "Saved state directory iintegrity error.",
    "Saved state directory iintegrity error.",
    "VERR_SSM_INTEGRITY_DIR",
     VERR_SSM_INTEGRITY_DIR }, 
  { "The saved state directory magic is wrong.",
    "The saved state directory magic is wrong.",
    "VERR_SSM_INTEGRITY_DIR_MAGIC",
     VERR_SSM_INTEGRITY_DIR_MAGIC }, 
  { "A data unit in the saved state file was defined but didn't any routine for processing it.",
    "A data unit in the saved state file was defined but didn't any routine for processing it.",
    "VERR_SSM_NO_LOAD_EXEC",
     VERR_SSM_NO_LOAD_EXEC }, 
  { "A restore routine attempted to load more data then the unit contained.",
    "A restore routine attempted to load more data then the unit contained.",
    "VERR_SSM_LOADED_TOO_MUCH",
     VERR_SSM_LOADED_TOO_MUCH }, 
  { "Not in the correct state for the attempted operation.",
    "Not in the correct state for the attempted operation.",
    "VERR_SSM_INVALID_STATE",
     VERR_SSM_INVALID_STATE }, 
  { "Not in the correct state for the attempted operation.",
    "Not in the correct state for the attempted operation.",
    "VERR_SSM_LOADED_TOO_LITTLE",
     VERR_SSM_LOADED_TOO_LITTLE }, 
  { "Unsupported data unit version.",
    "Unsupported data unit version. A SSM user returns this if it doesn't know the u32Version.",
    "VERR_SSM_UNSUPPORTED_DATA_UNIT_VERSION",
     VERR_SSM_UNSUPPORTED_DATA_UNIT_VERSION }, 
  { "The format of a data unit has changed.",
    "The format of a data unit has changed. A SSM user returns this if it's not able to read the format for other reasons than u32Version.",
    "VERR_SSM_DATA_UNIT_FORMAT_CHANGED",
     VERR_SSM_DATA_UNIT_FORMAT_CHANGED }, 
  { "The CPUID instruction returns different information when loading than when saved.",
    "The CPUID instruction returns different information when loading than when saved. Normally caused by hardware changes on the host, but could also be caused by changes in the BIOS setup.",
    "VERR_SSM_LOAD_CPUID_MISMATCH",
     VERR_SSM_LOAD_CPUID_MISMATCH }, 
  { "The RAM size differes between the saved state and the VM config.",
    "The RAM size differes between the saved state and the VM config.",
    "VERR_SSM_LOAD_MEMORY_SIZE_MISMATCH",
     VERR_SSM_LOAD_MEMORY_SIZE_MISMATCH }, 
  { "The state doesn't match the VM configuration in one or another way.",
    "The state doesn't match the VM configuration in one or another way. (There are certain PCI reconfiguration which the OS could potentially do which can cause this problem. Check this out when it happens.).",
    "VERR_SSM_LOAD_CONFIG_MISMATCH",
     VERR_SSM_LOAD_CONFIG_MISMATCH }, 
  { "The virtual clock frequency differs too much.",
    "The virtual clock frequency differs too much. The clock source for the virtual time isn't reliable or the code have changed.",
    "VERR_SSM_VIRTUAL_CLOCK_HZ",
     VERR_SSM_VIRTUAL_CLOCK_HZ }, 
  { "A timeout occurred while waiting for async IDE operations to finish.",
    "A timeout occurred while waiting for async IDE operations to finish.",
    "VERR_SSM_IDE_ASYNC_TIMEOUT",
     VERR_SSM_IDE_ASYNC_TIMEOUT }, 
  { "One of the structure magics was wrong.",
    "One of the structure magics was wrong.",
    "VERR_SSM_STRUCTURE_MAGIC",
     VERR_SSM_STRUCTURE_MAGIC }, 
  { "The data in the saved state doesn't conform to expectations.",
    "The data in the saved state doesn't conform to expectations.",
    "VERR_SSM_UNEXPECTED_DATA",
     VERR_SSM_UNEXPECTED_DATA }, 
  { "Trying to read a 64-bit guest physical address into a 32-bit variable.",
    "Trying to read a 64-bit guest physical address into a 32-bit variable.",
    "VERR_SSM_GCPHYS_OVERFLOW",
     VERR_SSM_GCPHYS_OVERFLOW }, 
  { "Trying to read a 64-bit guest virtual address into a 32-bit variable.",
    "Trying to read a 64-bit guest virtual address into a 32-bit variable.",
    "VERR_SSM_GCPTR_OVERFLOW",
     VERR_SSM_GCPTR_OVERFLOW }, 
  { "Vote for another pass.",
    "Vote for another pass.",
    "VINF_SSM_VOTE_FOR_ANOTHER_PASS",
     VINF_SSM_VOTE_FOR_ANOTHER_PASS }, 
  { "Vote for done tell SSM not to call again until the final pass.",
    "Vote for done tell SSM not to call again until the final pass.",
    "VINF_SSM_VOTE_DONE_DONT_CALL_AGAIN",
     VINF_SSM_VOTE_DONE_DONT_CALL_AGAIN }, 
  { "Vote for giving up.",
    "Vote for giving up.",
    "VERR_SSM_VOTE_FOR_GIVING_UP",
     VERR_SSM_VOTE_FOR_GIVING_UP }, 
  { "Don't call again until the final pass.",
    "Don't call again until the final pass.",
    "VINF_SSM_DONT_CALL_AGAIN",
     VINF_SSM_DONT_CALL_AGAIN }, 
  { "Giving up a live snapshot/teleportation attempt because of too many passes.",
    "Giving up a live snapshot/teleportation attempt because of too many passes.",
    "VERR_SSM_TOO_MANY_PASSES",
     VERR_SSM_TOO_MANY_PASSES }, 
  { "Giving up a live snapshot/teleportation attempt because the state grew to big.",
    "Giving up a live snapshot/teleportation attempt because the state grew to big.",
    "VERR_SSM_STATE_GREW_TOO_BIG",
     VERR_SSM_STATE_GREW_TOO_BIG }, 
  { "Giving up a live snapshot attempt because we're low on disk space.",
    "Giving up a live snapshot attempt because we're low on disk space.",
    "VERR_SSM_LOW_ON_DISK_SPACE",
     VERR_SSM_LOW_ON_DISK_SPACE }, 
  { "The operation was cancelled.",
    "The operation was cancelled.",
    "VERR_SSM_CANCELLED",
     VERR_SSM_CANCELLED }, 
  { "Nothing that can be cancelled.",
    "Nothing that can be cancelled.",
    "VERR_SSM_NO_PENDING_OPERATION",
     VERR_SSM_NO_PENDING_OPERATION }, 
  { "The operation has already been cancelled.",
    "The operation has already been cancelled.",
    "VERR_SSM_ALREADY_CANCELLED",
     VERR_SSM_ALREADY_CANCELLED }, 
  { "The machine was powered off while saving.",
    "The machine was powered off while saving.",
    "VERR_SSM_LIVE_POWERED_OFF",
     VERR_SSM_LIVE_POWERED_OFF }, 
  { "The live snapshot/teleportation operation was aborted because of a guru meditation.",
    "The live snapshot/teleportation operation was aborted because of a guru meditation.",
    "VERR_SSM_LIVE_GURU_MEDITATION",
     VERR_SSM_LIVE_GURU_MEDITATION }, 
  { "The live snapshot/teleportation operation was aborted because of a fatal runtime error.",
    "The live snapshot/teleportation operation was aborted because of a fatal runtime error.",
    "VERR_SSM_LIVE_FATAL_ERROR",
     VERR_SSM_LIVE_FATAL_ERROR }, 
  { "The VM was suspended before or while saving, don't resume execution.",
    "The VM was suspended before or while saving, don't resume execution.",
    "VINF_SSM_LIVE_SUSPENDED",
     VINF_SSM_LIVE_SUSPENDED }, 
  { "Complex SSM field fed to SSMR3PutStruct or SSMR3GetStruct.",
    "Complex SSM field fed to SSMR3PutStruct or SSMR3GetStruct. Use the extended API.",
    "VERR_SSM_FIELD_COMPLEX",
     VERR_SSM_FIELD_COMPLEX }, 
  { "Invalid size of a SSM field with the specified transformation.",
    "Invalid size of a SSM field with the specified transformation.",
    "VERR_SSM_FIELD_INVALID_SIZE",
     VERR_SSM_FIELD_INVALID_SIZE }, 
  { "The specified field is outside the structure.",
    "The specified field is outside the structure.",
    "VERR_SSM_FIELD_OUT_OF_BOUNDS",
     VERR_SSM_FIELD_OUT_OF_BOUNDS }, 
  { "The field does not follow immediately the previous one.",
    "The field does not follow immediately the previous one.",
    "VERR_SSM_FIELD_NOT_CONSECUTIVE",
     VERR_SSM_FIELD_NOT_CONSECUTIVE }, 
  { "The field contains an invalid callback or transformation index.",
    "The field contains an invalid callback or transformation index.",
    "VERR_SSM_FIELD_INVALID_CALLBACK",
     VERR_SSM_FIELD_INVALID_CALLBACK }, 
  { "The field contains an invalid padding size.",
    "The field contains an invalid padding size.",
    "VERR_SSM_FIELD_INVALID_PADDING_SIZE",
     VERR_SSM_FIELD_INVALID_PADDING_SIZE }, 
  { "The field contains a value that is out of range.",
    "The field contains a value that is out of range.",
    "VERR_SSM_FIELD_INVALID_VALUE",
     VERR_SSM_FIELD_INVALID_VALUE }, 
  { "Generic stream error.",
    "Generic stream error.",
    "VERR_SSM_STREAM_ERROR",
     VERR_SSM_STREAM_ERROR }, 
  { "SSM did a callback for a pass we didn't expect.",
    "SSM did a callback for a pass we didn't expect.",
    "VERR_SSM_UNEXPECTED_PASS",
     VERR_SSM_UNEXPECTED_PASS }, 
  { "Someone is trying to skip backwards in the stream...",
    "Someone is trying to skip backwards in the stream...",
    "VERR_SSM_SKIP_BACKWARDS",
     VERR_SSM_SKIP_BACKWARDS }, 
  { "Someone is trying to write a memory block which is too big to encode.",
    "Someone is trying to write a memory block which is too big to encode.",
    "VERR_SSM_MEM_TOO_BIG",
     VERR_SSM_MEM_TOO_BIG }, 
  { "Encountered an bad (/unknown) record type.",
    "Encountered an bad (/unknown) record type.",
    "VERR_SSM_BAD_REC_TYPE",
     VERR_SSM_BAD_REC_TYPE }, 
  { "Internal processing error #1 in SSM code.",
    "Internal processing error #1 in SSM code.",
    "VERR_SSM_IPE_1",
     VERR_SSM_IPE_1 }, 
  { "Internal processing error #2 in SSM code.",
    "Internal processing error #2 in SSM code.",
    "VERR_SSM_IPE_2",
     VERR_SSM_IPE_2 }, 
  { "Internal processing error #3 in SSM code.",
    "Internal processing error #3 in SSM code.",
    "VERR_SSM_IPE_3",
     VERR_SSM_IPE_3 }, 
  { "The specified at reset handler wasn't found.",
    "The specified at reset handler wasn't found.",
    "VERR_VM_ATRESET_NOT_FOUND",
     VERR_VM_ATRESET_NOT_FOUND }, 
  { "Invalid VM request type.",
    "Invalid VM request type. For the VMR3ReqAlloc() case, the caller just specified an illegal enmType. For all the other occurrences it means indicates corruption, broken logic, or stupid interface user.",
    "VERR_VM_REQUEST_INVALID_TYPE",
     VERR_VM_REQUEST_INVALID_TYPE }, 
  { "Invalid VM request state.",
    "Invalid VM request state. The state of the request packet was not the expected and accepted one(s). Either the interface user screwed up, or we've got corruption/broken logic.",
    "VERR_VM_REQUEST_STATE",
     VERR_VM_REQUEST_STATE }, 
  { "Invalid VM request packet.",
    "Invalid VM request packet. One or more of the the VM controlled packet members didn't contain the correct values. Some thing's broken.",
    "VERR_VM_REQUEST_INVALID_PACKAGE",
     VERR_VM_REQUEST_INVALID_PACKAGE }, 
  { "The status field has not been updated yet as the request is still pending completion.",
    "The status field has not been updated yet as the request is still pending completion. Someone queried the iStatus field before the request has been fully processed.",
    "VERR_VM_REQUEST_STATUS_STILL_PENDING",
     VERR_VM_REQUEST_STATUS_STILL_PENDING }, 
  { "The request has been freed, don't read the status now.",
    "The request has been freed, don't read the status now. Someone is reading the iStatus field of a freed request packet.",
    "VERR_VM_REQUEST_STATUS_FREED",
     VERR_VM_REQUEST_STATUS_FREED }, 
  { "A VM api requiring EMT was called from another thread.",
    "A VM api requiring EMT was called from another thread. Use the VMR3ReqCall() apis to call it!.",
    "VERR_VM_THREAD_NOT_EMT",
     VERR_VM_THREAD_NOT_EMT }, 
  { "The VM state was invalid for the requested operation.",
    "The VM state was invalid for the requested operation. Go check the 'VM Statechart Diagram.gif'.",
    "VERR_VM_INVALID_VM_STATE",
     VERR_VM_INVALID_VM_STATE }, 
  { "The support driver is not installed.",
    "The support driver is not installed. On linux, open returned ENOENT.",
    "VERR_VM_DRIVER_NOT_INSTALLED",
     VERR_VM_DRIVER_NOT_INSTALLED }, 
  { "The support driver is not accessible.",
    "The support driver is not accessible. On linux, open returned EPERM.",
    "VERR_VM_DRIVER_NOT_ACCESSIBLE",
     VERR_VM_DRIVER_NOT_ACCESSIBLE }, 
  { "Was not able to load the support driver.",
    "Was not able to load the support driver. On linux, open returned ENODEV.",
    "VERR_VM_DRIVER_LOAD_ERROR",
     VERR_VM_DRIVER_LOAD_ERROR }, 
  { "Was not able to open the support driver.",
    "Was not able to open the support driver. Generic open error used when none of the other ones fit.",
    "VERR_VM_DRIVER_OPEN_ERROR",
     VERR_VM_DRIVER_OPEN_ERROR }, 
  { "The installed support driver doesn't match the version of the user.",
    "The installed support driver doesn't match the version of the user.",
    "VERR_VM_DRIVER_VERSION_MISMATCH",
     VERR_VM_DRIVER_VERSION_MISMATCH }, 
  { "Saving the VM state is temporarily not allowed.",
    "Saving the VM state is temporarily not allowed. Try again later.",
    "VERR_VM_SAVE_STATE_NOT_ALLOWED",
     VERR_VM_SAVE_STATE_NOT_ALLOWED }, 
  { "An EMT called an API which cannot be called on such a thread.",
    "An EMT called an API which cannot be called on such a thread.",
    "VERR_VM_THREAD_IS_EMT",
     VERR_VM_THREAD_IS_EMT }, 
  { "Encountered an unexpected VM state.",
    "Encountered an unexpected VM state.",
    "VERR_VM_UNEXPECTED_VM_STATE",
     VERR_VM_UNEXPECTED_VM_STATE }, 
  { "Unexpected unstable VM state.",
    "Unexpected unstable VM state.",
    "VERR_VM_UNEXPECTED_UNSTABLE_STATE",
     VERR_VM_UNEXPECTED_UNSTABLE_STATE }, 
  { "Too many arguments passed to a VM request / request corruption.",
    "Too many arguments passed to a VM request / request corruption.",
    "VERR_VM_REQUEST_TOO_MANY_ARGS_IPE",
     VERR_VM_REQUEST_TOO_MANY_ARGS_IPE }, 
  { "Fatal EMT wait error.",
    "Fatal EMT wait error.",
    "VERR_VM_FATAL_WAIT_ERROR",
     VERR_VM_FATAL_WAIT_ERROR }, 
  { "The VM request was killed at VM termination.",
    "The VM request was killed at VM termination.",
    "VERR_VM_REQUEST_KILLED",
     VERR_VM_REQUEST_KILLED }, 
  { "Successful completion of operation (mapped to generic iprt status code).",
    "Successful completion of operation (mapped to generic iprt status code).",
    "VINF_VRDP_SUCCESS",
     VINF_VRDP_SUCCESS }, 
  { "VRDP transport operation timed out (mapped to generic iprt status code).",
    "VRDP transport operation timed out (mapped to generic iprt status code).",
    "VERR_VRDP_TIMEOUT",
     VERR_VRDP_TIMEOUT }, 
  { "Unsupported ISO protocol feature.",
    "Unsupported ISO protocol feature.",
    "VERR_VRDP_ISO_UNSUPPORTED",
     VERR_VRDP_ISO_UNSUPPORTED }, 
  { "Security (en/decryption) engine error.",
    "Security (en/decryption) engine error.",
    "VERR_VRDP_SEC_ENGINE_FAIL",
     VERR_VRDP_SEC_ENGINE_FAIL }, 
  { "VRDP protocol violation.",
    "VRDP protocol violation.",
    "VERR_VRDP_PROTOCOL_ERROR",
     VERR_VRDP_PROTOCOL_ERROR }, 
  { "Unsupported VRDP protocol feature.",
    "Unsupported VRDP protocol feature.",
    "VERR_VRDP_NOT_SUPPORTED",
     VERR_VRDP_NOT_SUPPORTED }, 
  { "VRDP protocol violation, client sends less data than expected.",
    "VRDP protocol violation, client sends less data than expected.",
    "VERR_VRDP_INSUFFICIENT_DATA",
     VERR_VRDP_INSUFFICIENT_DATA }, 
  { "Internal error, VRDP packet is in wrong operation mode.",
    "Internal error, VRDP packet is in wrong operation mode.",
    "VERR_VRDP_INVALID_MODE",
     VERR_VRDP_INVALID_MODE }, 
  { "Memory allocation failed.",
    "Memory allocation failed.",
    "VERR_VRDP_NO_MEMORY",
     VERR_VRDP_NO_MEMORY }, 
  { "Client has been rejected.",
    "Client has been rejected.",
    "VERR_VRDP_ACCESS_DENIED",
     VERR_VRDP_ACCESS_DENIED }, 
  { "VRPD receives a packet that is not supported.",
    "VRPD receives a packet that is not supported.",
    "VWRN_VRDP_PDU_NOT_SUPPORTED",
     VWRN_VRDP_PDU_NOT_SUPPORTED }, 
  { "VRDP script allowed the packet to be processed further.",
    "VRDP script allowed the packet to be processed further.",
    "VINF_VRDP_PROCESS_PDU",
     VINF_VRDP_PROCESS_PDU }, 
  { "VRDP script has completed its task.",
    "VRDP script has completed its task.",
    "VINF_VRDP_OPERATION_COMPLETED",
     VINF_VRDP_OPERATION_COMPLETED }, 
  { "VRDP thread has started OK and will run.",
    "VRDP thread has started OK and will run.",
    "VINF_VRDP_THREAD_STARTED",
     VINF_VRDP_THREAD_STARTED }, 
  { "Framebuffer is resized, terminate send bitmap procedure.",
    "Framebuffer is resized, terminate send bitmap procedure.",
    "VINF_VRDP_RESIZE_REQUESTED",
     VINF_VRDP_RESIZE_REQUESTED }, 
  { "Output can be enabled for the client.",
    "Output can be enabled for the client.",
    "VINF_VRDP_OUTPUT_ENABLE",
     VINF_VRDP_OUTPUT_ENABLE }, 
  { "The integer value was too big for the requested representation.",
    "The integer value was too big for the requested representation.",
    "VERR_CFGM_INTEGER_TOO_BIG",
     VERR_CFGM_INTEGER_TOO_BIG }, 
  { "Child node was not found.",
    "Child node was not found.",
    "VERR_CFGM_CHILD_NOT_FOUND",
     VERR_CFGM_CHILD_NOT_FOUND }, 
  { "Path to child node was invalid (i.",
    "Path to child node was invalid (i.e. empty).",
    "VERR_CFGM_INVALID_CHILD_PATH",
     VERR_CFGM_INVALID_CHILD_PATH }, 
  { "Value not found.",
    "Value not found.",
    "VERR_CFGM_VALUE_NOT_FOUND",
     VERR_CFGM_VALUE_NOT_FOUND }, 
  { "No parent node specified.",
    "No parent node specified.",
    "VERR_CFGM_NO_PARENT",
     VERR_CFGM_NO_PARENT }, 
  { "No node was specified.",
    "No node was specified.",
    "VERR_CFGM_NO_NODE",
     VERR_CFGM_NO_NODE }, 
  { "The value is not an integer.",
    "The value is not an integer.",
    "VERR_CFGM_NOT_INTEGER",
     VERR_CFGM_NOT_INTEGER }, 
  { "The value is not a zero terminated character string.",
    "The value is not a zero terminated character string.",
    "VERR_CFGM_NOT_STRING",
     VERR_CFGM_NOT_STRING }, 
  { "The value is not a byte string.",
    "The value is not a byte string.",
    "VERR_CFGM_NOT_BYTES",
     VERR_CFGM_NOT_BYTES }, 
  { "The specified string / bytes buffer was to small.",
    "The specified string / bytes buffer was to small. Specify a larger one and retry.",
    "VERR_CFGM_NOT_ENOUGH_SPACE",
     VERR_CFGM_NOT_ENOUGH_SPACE }, 
  { "The path of a new node contained slashs or was empty.",
    "The path of a new node contained slashs or was empty.",
    "VERR_CFGM_INVALID_NODE_PATH",
     VERR_CFGM_INVALID_NODE_PATH }, 
  { "A new node couldn't be inserted because one with the same name exists.",
    "A new node couldn't be inserted because one with the same name exists.",
    "VERR_CFGM_NODE_EXISTS",
     VERR_CFGM_NODE_EXISTS }, 
  { "A new leaf couldn't be inserted because one with the same name exists.",
    "A new leaf couldn't be inserted because one with the same name exists.",
    "VERR_CFGM_LEAF_EXISTS",
     VERR_CFGM_LEAF_EXISTS }, 
  { "An unknown config value was encountered.",
    "An unknown config value was encountered.",
    "VERR_CFGM_CONFIG_UNKNOWN_VALUE",
     VERR_CFGM_CONFIG_UNKNOWN_VALUE }, 
  { "An unknown config node (key) was encountered.",
    "An unknown config node (key) was encountered.",
    "VERR_CFGM_CONFIG_UNKNOWN_NODE",
     VERR_CFGM_CONFIG_UNKNOWN_NODE }, 
  { "Internal processing error #1 in CFGM.",
    "Internal processing error #1 in CFGM.",
    "VERR_CFGM_IPE_1",
     VERR_CFGM_IPE_1 }, 
  { "The loaded timer state was incorrect.",
    "The loaded timer state was incorrect.",
    "VERR_TM_LOAD_STATE",
     VERR_TM_LOAD_STATE }, 
  { "The timer was not in the correct state for the request operation.",
    "The timer was not in the correct state for the request operation.",
    "VERR_TM_INVALID_STATE",
     VERR_TM_INVALID_STATE }, 
  { "The timer was in a unknown state.",
    "The timer was in a unknown state. Corruption or stupid coding error.",
    "VERR_TM_UNKNOWN_STATE",
     VERR_TM_UNKNOWN_STATE }, 
  { "The timer was stuck in an unstable state until we grew impatient and returned.",
    "The timer was stuck in an unstable state until we grew impatient and returned.",
    "VERR_TM_UNSTABLE_STATE",
     VERR_TM_UNSTABLE_STATE }, 
  { "TM requires GIP.",
    "TM requires GIP.",
    "VERR_TM_GIP_REQUIRED",
     VERR_TM_GIP_REQUIRED }, 
  { "TM does not support the GIP version.",
    "TM does not support the GIP version.",
    "VERR_TM_GIP_VERSION",
     VERR_TM_GIP_VERSION }, 
  { "The GIP update interval is too large.",
    "The GIP update interval is too large.",
    "VERR_TM_GIP_UPDATE_INTERVAL_TOO_BIG",
     VERR_TM_GIP_UPDATE_INTERVAL_TOO_BIG }, 
  { "The timer has a bad clock enum value, probably corruption.",
    "The timer has a bad clock enum value, probably corruption.",
    "VERR_TM_TIMER_BAD_CLOCK",
     VERR_TM_TIMER_BAD_CLOCK }, 
  { "The timer failed to reach a stable state.",
    "The timer failed to reach a stable state.",
    "VERR_TM_TIMER_UNSTABLE_STATE",
     VERR_TM_TIMER_UNSTABLE_STATE }, 
  { "Attempt to resume a running TSC.",
    "Attempt to resume a running TSC.",
    "VERR_TM_TSC_ALREADY_TICKING",
     VERR_TM_TSC_ALREADY_TICKING }, 
  { "Attempt to pause a paused TSC.",
    "Attempt to pause a paused TSC.",
    "VERR_TM_TSC_ALREADY_PAUSED",
     VERR_TM_TSC_ALREADY_PAUSED }, 
  { "Invalid value for cVirtualTicking.",
    "Invalid value for cVirtualTicking.",
    "VERR_TM_VIRTUAL_TICKING_IPE",
     VERR_TM_VIRTUAL_TICKING_IPE }, 
  { "Fatal error in virtual hardware.",
    "Fatal error in virtual hardware.",
    "VERR_REM_VIRTUAL_HARDWARE_ERROR",
     VERR_REM_VIRTUAL_HARDWARE_ERROR }, 
  { "Fatal error in the recompiler cpu.",
    "Fatal error in the recompiler cpu.",
    "VERR_REM_VIRTUAL_CPU_ERROR",
     VERR_REM_VIRTUAL_CPU_ERROR }, 
  { "Recompiler execution was interrupted by forced action.",
    "Recompiler execution was interrupted by forced action.",
    "VINF_REM_INTERRUPED_FF",
     VINF_REM_INTERRUPED_FF }, 
  { "Too many similar traps.",
    "Too many similar traps. This is a very useful debug only check (we don't do double/triple faults in REM).",
    "VERR_REM_TOO_MANY_TRAPS",
     VERR_REM_TOO_MANY_TRAPS }, 
  { "The REM is out of breakpoint slots.",
    "The REM is out of breakpoint slots.",
    "VERR_REM_NO_MORE_BP_SLOTS",
     VERR_REM_NO_MORE_BP_SLOTS }, 
  { "The REM could not find any breakpoint on the specified address.",
    "The REM could not find any breakpoint on the specified address.",
    "VERR_REM_BP_NOT_FOUND",
     VERR_REM_BP_NOT_FOUND }, 
  { "No active trap.",
    "No active trap. Cannot query or reset a non-existing trap.",
    "VERR_TRPM_NO_ACTIVE_TRAP",
     VERR_TRPM_NO_ACTIVE_TRAP }, 
  { "Active trap.",
    "Active trap. Cannot assert a new trap when when one is already active.",
    "VERR_TRPM_ACTIVE_TRAP",
     VERR_TRPM_ACTIVE_TRAP }, 
  { "Reason for leaving GC: Guest tried to write to our IDT - fatal.",
    "Reason for leaving GC: Guest tried to write to our IDT - fatal. The VM will be terminated assuming the worst, i.e. that the guest has read the idtr register.",
    "VERR_TRPM_SHADOW_IDT_WRITE",
     VERR_TRPM_SHADOW_IDT_WRITE }, 
  { "Reason for leaving GC: Fatal trap in hypervisor.",
    "Reason for leaving GC: Fatal trap in hypervisor.",
    "VERR_TRPM_DONT_PANIC",
     VERR_TRPM_DONT_PANIC }, 
  { "Reason for leaving GC: Double Fault.",
    "Reason for leaving GC: Double Fault.",
    "VERR_TRPM_PANIC",
     VERR_TRPM_PANIC }, 
  { "The exception was dispatched for raw-mode execution.",
    "The exception was dispatched for raw-mode execution.",
    "VINF_TRPM_XCPT_DISPATCHED",
     VINF_TRPM_XCPT_DISPATCHED }, 
  { "Bad TRPM_TRAP_IN_OP.",
    "Bad TRPM_TRAP_IN_OP.",
    "VERR_TRPM_BAD_TRAP_IN_OP",
     VERR_TRPM_BAD_TRAP_IN_OP }, 
  { "Internal processing error #1 in TRPM.",
    "Internal processing error #1 in TRPM.",
    "VERR_TRPM_IPE_1",
     VERR_TRPM_IPE_1 }, 
  { "Internal processing error #2 in TRPM.",
    "Internal processing error #2 in TRPM.",
    "VERR_TRPM_IPE_2",
     VERR_TRPM_IPE_2 }, 
  { "Internal processing error #3 in TRPM.",
    "Internal processing error #3 in TRPM.",
    "VERR_TRPM_IPE_3",
     VERR_TRPM_IPE_3 }, 
  { "Reason for leaving GC: Guest tried to write to our GDT - fatal.",
    "Reason for leaving GC: Guest tried to write to our GDT - fatal. The VM will be terminated assuming the worst, i.e. that the guest has read the gdtr register.",
    "VERR_SELM_SHADOW_GDT_WRITE",
     VERR_SELM_SHADOW_GDT_WRITE }, 
  { "Reason for leaving GC: Guest tried to write to our LDT - fatal.",
    "Reason for leaving GC: Guest tried to write to our LDT - fatal. The VM will be terminated assuming the worst, i.e. that the guest has read the ldtr register.",
    "VERR_SELM_SHADOW_LDT_WRITE",
     VERR_SELM_SHADOW_LDT_WRITE }, 
  { "Reason for leaving GC: Guest tried to write to our TSS - fatal.",
    "Reason for leaving GC: Guest tried to write to our TSS - fatal. The VM will be terminated assuming the worst, i.e. that the guest has read the ltr register.",
    "VERR_SELM_SHADOW_TSS_WRITE",
     VERR_SELM_SHADOW_TSS_WRITE }, 
  { "Reason for leaving GC: Sync the GDT table to solve a conflict.",
    "Reason for leaving GC: Sync the GDT table to solve a conflict.",
    "VINF_SELM_SYNC_GDT",
     VINF_SELM_SYNC_GDT }, 
  { "No valid TSS present.",
    "No valid TSS present.",
    "VERR_SELM_NO_TSS",
     VERR_SELM_NO_TSS }, 
  { "Invalid guest LDT selector.",
    "Invalid guest LDT selector.",
    "VERR_SELM_INVALID_LDT",
     VERR_SELM_INVALID_LDT }, 
  { "The guest LDT selector is out of bounds.",
    "The guest LDT selector is out of bounds.",
    "VERR_SELM_LDT_OUT_OF_BOUNDS",
     VERR_SELM_LDT_OUT_OF_BOUNDS }, 
  { "The specified I/O port range was invalid.",
    "The specified I/O port range was invalid. It was either empty or it was out of bounds.",
    "VERR_IOM_INVALID_IOPORT_RANGE",
     VERR_IOM_INVALID_IOPORT_RANGE }, 
  { "The specified GC I/O port range didn't have a corresponding HC range.",
    "The specified GC I/O port range didn't have a corresponding HC range. IOMIOPortRegisterHC() must be called before IOMIOPortRegisterGC().",
    "VERR_IOM_NO_HC_IOPORT_RANGE",
     VERR_IOM_NO_HC_IOPORT_RANGE }, 
  { "The specified I/O port range intruded on an existing range.",
    "The specified I/O port range intruded on an existing range. There is a I/O port conflict between two device, or a device tried to register the same range twice.",
    "VERR_IOM_IOPORT_RANGE_CONFLICT",
     VERR_IOM_IOPORT_RANGE_CONFLICT }, 
  { "The I/O port range specified for removal wasn't found or it wasn't contiguous.",
    "The I/O port range specified for removal wasn't found or it wasn't contiguous.",
    "VERR_IOM_IOPORT_RANGE_NOT_FOUND",
     VERR_IOM_IOPORT_RANGE_NOT_FOUND }, 
  { "The specified I/O port range was owned by some other device(s).",
    "The specified I/O port range was owned by some other device(s). Both registration and deregistration, but in the first case only GC ranges.",
    "VERR_IOM_NOT_IOPORT_RANGE_OWNER",
     VERR_IOM_NOT_IOPORT_RANGE_OWNER }, 
  { "The specified MMIO range was invalid.",
    "The specified MMIO range was invalid. It was either empty or it was out of bounds.",
    "VERR_IOM_INVALID_MMIO_RANGE",
     VERR_IOM_INVALID_MMIO_RANGE }, 
  { "The specified GC MMIO range didn't have a corresponding HC range.",
    "The specified GC MMIO range didn't have a corresponding HC range. IOMMMIORegisterHC() must be called before IOMMMIORegisterGC().",
    "VERR_IOM_NO_HC_MMIO_RANGE",
     VERR_IOM_NO_HC_MMIO_RANGE }, 
  { "The specified MMIO range was owned by some other device(s).",
    "The specified MMIO range was owned by some other device(s). Both registration and deregistration, but in the first case only GC ranges.",
    "VERR_IOM_NOT_MMIO_RANGE_OWNER",
     VERR_IOM_NOT_MMIO_RANGE_OWNER }, 
  { "The specified MMIO range intruded on an existing range.",
    "The specified MMIO range intruded on an existing range. There is a MMIO conflict between two device, or a device tried to register the same range twice.",
    "VERR_IOM_MMIO_RANGE_CONFLICT",
     VERR_IOM_MMIO_RANGE_CONFLICT }, 
  { "The MMIO range specified for removal was not found.",
    "The MMIO range specified for removal was not found.",
    "VERR_IOM_MMIO_RANGE_NOT_FOUND",
     VERR_IOM_MMIO_RANGE_NOT_FOUND }, 
  { "The MMIO range specified for removal was invalid.",
    "The MMIO range specified for removal was invalid. The range didn't match quite match a set of existing ranges. It's not possible to remove parts of a MMIO range, only one or more full ranges.",
    "VERR_IOM_INCOMPLETE_MMIO_RANGE",
     VERR_IOM_INCOMPLETE_MMIO_RANGE }, 
  { "An invalid I/O port size was specified for a read or write operation.",
    "An invalid I/O port size was specified for a read or write operation.",
    "VERR_IOM_INVALID_IOPORT_SIZE",
     VERR_IOM_INVALID_IOPORT_SIZE }, 
  { "The MMIO handler was called for a bogus address!",
    "The MMIO handler was called for a bogus address! Internal error!.",
    "VERR_IOM_MMIO_HANDLER_BOGUS_CALL",
     VERR_IOM_MMIO_HANDLER_BOGUS_CALL }, 
  { "The MMIO handler experienced a problem with the disassembler.",
    "The MMIO handler experienced a problem with the disassembler.",
    "VERR_IOM_MMIO_HANDLER_DISASM_ERROR",
     VERR_IOM_MMIO_HANDLER_DISASM_ERROR }, 
  { "The port being read was not present(/unused) and IOM shall return ~0 according to size.",
    "The port being read was not present(/unused) and IOM shall return ~0 according to size.",
    "VERR_IOM_IOPORT_UNUSED",
     VERR_IOM_IOPORT_UNUSED }, 
  { "Unused MMIO register read, fill with 00.",
    "Unused MMIO register read, fill with 00.",
    "VINF_IOM_MMIO_UNUSED_00",
     VINF_IOM_MMIO_UNUSED_00 }, 
  { "Unused MMIO register read, fill with FF.",
    "Unused MMIO register read, fill with FF.",
    "VINF_IOM_MMIO_UNUSED_FF",
     VINF_IOM_MMIO_UNUSED_FF }, 
  { "Reason for leaving GC: I/O port read.",
    "Reason for leaving GC: I/O port read.",
    "VINF_IOM_HC_IOPORT_READ",
     VINF_IOM_HC_IOPORT_READ }, 
  { "Reason for leaving GC: I/O port write.",
    "Reason for leaving GC: I/O port write.",
    "VINF_IOM_HC_IOPORT_WRITE",
     VINF_IOM_HC_IOPORT_WRITE }, 
  { "Reason for leaving GC: MMIO write.",
    "Reason for leaving GC: MMIO write.",
    "VINF_IOM_HC_MMIO_READ",
     VINF_IOM_HC_MMIO_READ }, 
  { "Reason for leaving GC: MMIO read.",
    "Reason for leaving GC: MMIO read.",
    "VINF_IOM_HC_MMIO_WRITE",
     VINF_IOM_HC_MMIO_WRITE }, 
  { "Reason for leaving GC: MMIO read/write.",
    "Reason for leaving GC: MMIO read/write.",
    "VINF_IOM_HC_MMIO_READ_WRITE",
     VINF_IOM_HC_MMIO_READ_WRITE }, 
  { "IOMGCIOPortHandler was given an unexpected opcode.",
    "IOMGCIOPortHandler was given an unexpected opcode.",
    "VERR_IOM_IOPORT_UNKNOWN_OPCODE",
     VERR_IOM_IOPORT_UNKNOWN_OPCODE }, 
  { "Internal processing error #1 in the I/O port code.",
    "Internal processing error #1 in the I/O port code.",
    "VERR_IOM_IOPORT_IPE_1",
     VERR_IOM_IOPORT_IPE_1 }, 
  { "Internal processing error #2 in the I/O port code.",
    "Internal processing error #2 in the I/O port code.",
    "VERR_IOM_IOPORT_IPE_2",
     VERR_IOM_IOPORT_IPE_2 }, 
  { "Internal processing error #3 in the I/O port code.",
    "Internal processing error #3 in the I/O port code.",
    "VERR_IOM_IOPORT_IPE_3",
     VERR_IOM_IOPORT_IPE_3 }, 
  { "Internal processing error #1 in the MMIO code.",
    "Internal processing error #1 in the MMIO code.",
    "VERR_IOM_MMIO_IPE_1",
     VERR_IOM_MMIO_IPE_1 }, 
  { "Internal processing error #2 in the MMIO code.",
    "Internal processing error #2 in the MMIO code.",
    "VERR_IOM_MMIO_IPE_2",
     VERR_IOM_MMIO_IPE_2 }, 
  { "Internal processing error #3 in the MMIO code.",
    "Internal processing error #3 in the MMIO code.",
    "VERR_IOM_MMIO_IPE_3",
     VERR_IOM_MMIO_IPE_3 }, 
  { "Reason for leaving RZ: Calling host function.",
    "Reason for leaving RZ: Calling host function.",
    "VINF_VMM_CALL_HOST",
     VINF_VMM_CALL_HOST }, 
  { "Reason for leaving R0: Hit a ring-0 assertion on EMT.",
    "Reason for leaving R0: Hit a ring-0 assertion on EMT.",
    "VERR_VMM_RING0_ASSERTION",
     VERR_VMM_RING0_ASSERTION }, 
  { "The hyper CR3 differs between PGM and CPUM.",
    "The hyper CR3 differs between PGM and CPUM.",
    "VERR_VMM_HYPER_CR3_MISMATCH",
     VERR_VMM_HYPER_CR3_MISMATCH }, 
  { "Reason for leaving RZ: Illegal call to ring-3.",
    "Reason for leaving RZ: Illegal call to ring-3.",
    "VERR_VMM_RING3_CALL_DISABLED",
     VERR_VMM_RING3_CALL_DISABLED }, 
  { "The VMMR0.",
    "The VMMR0.r0 module version does not match VBoxVMM.dll/so/dylib. If you just upgraded VirtualBox, please terminate all VMs and make sure VBoxNetDHCP is not running. Then try again. If this error persists, try re-installing VirtualBox.",
    "VERR_VMM_R0_VERSION_MISMATCH",
     VERR_VMM_R0_VERSION_MISMATCH }, 
  { "The VMMRC.",
    "The VMMRC.rc module version does not match VBoxVMM.dll/so/dylib. Re-install if you are a user. Developers should make sure the build is complete or try with a clean build.",
    "VERR_VMM_RC_VERSION_MISMATCH",
     VERR_VMM_RC_VERSION_MISMATCH }, 
  { "VMM set jump error.",
    "VMM set jump error.",
    "VERR_VMM_SET_JMP_ERROR",
     VERR_VMM_SET_JMP_ERROR }, 
  { "VMM set jump stack overflow error.",
    "VMM set jump stack overflow error.",
    "VERR_VMM_SET_JMP_STACK_OVERFLOW",
     VERR_VMM_SET_JMP_STACK_OVERFLOW }, 
  { "VMM set jump resume error.",
    "VMM set jump resume error.",
    "VERR_VMM_SET_JMP_ABORTED_RESUME",
     VERR_VMM_SET_JMP_ABORTED_RESUME }, 
  { "VMM long jump error.",
    "VMM long jump error.",
    "VERR_VMM_LONG_JMP_ERROR",
     VERR_VMM_LONG_JMP_ERROR }, 
  { "Unknown ring-3 call attempted.",
    "Unknown ring-3 call attempted.",
    "VERR_VMM_UNKNOWN_RING3_CALL",
     VERR_VMM_UNKNOWN_RING3_CALL }, 
  { "The ring-3 call didn't set an RC.",
    "The ring-3 call didn't set an RC.",
    "VERR_VMM_RING3_CALL_NO_RC",
     VERR_VMM_RING3_CALL_NO_RC }, 
  { "An invalid LUN specification was given.",
    "An invalid LUN specification was given.",
    "VERR_PDM_NO_SUCH_LUN",
     VERR_PDM_NO_SUCH_LUN }, 
  { "A device encountered an unknown configuration value.",
    "A device encountered an unknown configuration value. This means that the device is potentially misconfigured and the device construction or unit attachment failed because of this.",
    "VERR_PDM_DEVINS_UNKNOWN_CFG_VALUES",
     VERR_PDM_DEVINS_UNKNOWN_CFG_VALUES }, 
  { "The above driver doesn't export a interface required by a driver being attached to it.",
    "The above driver doesn't export a interface required by a driver being attached to it. Typical misconfiguration problem.",
    "VERR_PDM_MISSING_INTERFACE_ABOVE",
     VERR_PDM_MISSING_INTERFACE_ABOVE }, 
  { "The below driver doesn't export a interface required by the drive having attached it.",
    "The below driver doesn't export a interface required by the drive having attached it. Typical misconfiguration problem.",
    "VERR_PDM_MISSING_INTERFACE_BELOW",
     VERR_PDM_MISSING_INTERFACE_BELOW }, 
  { "A device didn't find a required interface with an attached driver.",
    "A device didn't find a required interface with an attached driver. Typical misconfiguration problem.",
    "VERR_PDM_MISSING_INTERFACE",
     VERR_PDM_MISSING_INTERFACE }, 
  { "A driver encountered an unknown configuration value.",
    "A driver encountered an unknown configuration value. This means that the driver is potentially misconfigured and the driver construction failed because of this.",
    "VERR_PDM_DRVINS_UNKNOWN_CFG_VALUES",
     VERR_PDM_DRVINS_UNKNOWN_CFG_VALUES }, 
  { "The PCI bus assigned to a device didn't have room for it.",
    "The PCI bus assigned to a device didn't have room for it. Either too many devices are configured on the same PCI bus, or there are some internal problem where PDM/PCI doesn't free up slots when unplugging devices.",
    "VERR_PDM_TOO_PCI_MANY_DEVICES",
     VERR_PDM_TOO_PCI_MANY_DEVICES }, 
  { "A queue is out of free items, the queueing operation failed.",
    "A queue is out of free items, the queueing operation failed.",
    "VERR_PDM_NO_QUEUE_ITEMS",
     VERR_PDM_NO_QUEUE_ITEMS }, 
  { "Not possible to attach further drivers to the driver.",
    "Not possible to attach further drivers to the driver. A driver which doesn't support attachments (below of course) will return this status code if it found that further drivers were configured to be attached to it.",
    "VERR_PDM_DRVINS_NO_ATTACH",
     VERR_PDM_DRVINS_NO_ATTACH }, 
  { "Not possible to attach drivers to the device.",
    "Not possible to attach drivers to the device. A device which doesn't support attachments (below of course) will return this status code if it found that drivers were configured to be attached to it.",
    "VERR_PDM_DEVINS_NO_ATTACH",
     VERR_PDM_DEVINS_NO_ATTACH }, 
  { "No attached driver.",
    "No attached driver. The PDMDRVHLP::pfnAttach and PDMDEVHLP::pfnDriverAttach will return this error when no driver was configured to be attached.",
    "VERR_PDM_NO_ATTACHED_DRIVER",
     VERR_PDM_NO_ATTACHED_DRIVER }, 
  { "The media geometry hasn't been set yet, so it cannot be obtained.",
    "The media geometry hasn't been set yet, so it cannot be obtained. The caller should then calculate the geometry from the media size.",
    "VERR_PDM_GEOMETRY_NOT_SET",
     VERR_PDM_GEOMETRY_NOT_SET }, 
  { "The media translation hasn't been set yet, so it cannot be obtained.",
    "The media translation hasn't been set yet, so it cannot be obtained. The caller should then guess the translation.",
    "VERR_PDM_TRANSLATION_NOT_SET",
     VERR_PDM_TRANSLATION_NOT_SET }, 
  { "The media is not mounted, operation requires a mounted media.",
    "The media is not mounted, operation requires a mounted media.",
    "VERR_PDM_MEDIA_NOT_MOUNTED",
     VERR_PDM_MEDIA_NOT_MOUNTED }, 
  { "Mount failed because a media was already mounted.",
    "Mount failed because a media was already mounted. Unmount the media and retry the mount.",
    "VERR_PDM_MEDIA_MOUNTED",
     VERR_PDM_MEDIA_MOUNTED }, 
  { "The media is locked and cannot be unmounted.",
    "The media is locked and cannot be unmounted.",
    "VERR_PDM_MEDIA_LOCKED",
     VERR_PDM_MEDIA_LOCKED }, 
  { "No 'Type' attribute in the DrvBlock configuration.",
    "No 'Type' attribute in the DrvBlock configuration. Misconfiguration.",
    "VERR_PDM_BLOCK_NO_TYPE",
     VERR_PDM_BLOCK_NO_TYPE }, 
  { "The 'Type' attribute in the DrvBlock configuration had an unknown value.",
    "The 'Type' attribute in the DrvBlock configuration had an unknown value. Misconfiguration.",
    "VERR_PDM_BLOCK_UNKNOWN_TYPE",
     VERR_PDM_BLOCK_UNKNOWN_TYPE }, 
  { "The 'Translation' attribute in the DrvBlock configuration had an unknown value.",
    "The 'Translation' attribute in the DrvBlock configuration had an unknown value. Misconfiguration.",
    "VERR_PDM_BLOCK_UNKNOWN_TRANSLATION",
     VERR_PDM_BLOCK_UNKNOWN_TRANSLATION }, 
  { "The block driver type wasn't supported.",
    "The block driver type wasn't supported. Misconfiguration of the kind you get when attaching a floppy to an IDE controller.",
    "VERR_PDM_UNSUPPORTED_BLOCK_TYPE",
     VERR_PDM_UNSUPPORTED_BLOCK_TYPE }, 
  { "A attach or prepare mount call failed because the driver already had a driver attached.",
    "A attach or prepare mount call failed because the driver already had a driver attached.",
    "VERR_PDM_DRIVER_ALREADY_ATTACHED",
     VERR_PDM_DRIVER_ALREADY_ATTACHED }, 
  { "An attempt on deattaching a driver without anyone actually being attached, or performing any other operation on an attached driver.",
    "An attempt on deattaching a driver without anyone actually being attached, or performing any other operation on an attached driver.",
    "VERR_PDM_NO_DRIVER_ATTACHED",
     VERR_PDM_NO_DRIVER_ATTACHED }, 
  { "The attached driver configuration is missing the 'Driver' attribute.",
    "The attached driver configuration is missing the 'Driver' attribute.",
    "VERR_PDM_CFG_MISSING_DRIVER_NAME",
     VERR_PDM_CFG_MISSING_DRIVER_NAME }, 
  { "The configured driver wasn't found.",
    "The configured driver wasn't found. Either the necessary driver modules wasn't loaded, the name was misspelled, or it was a misconfiguration.",
    "VERR_PDM_DRIVER_NOT_FOUND",
     VERR_PDM_DRIVER_NOT_FOUND }, 
  { "The Ring-3 module was already loaded.",
    "The Ring-3 module was already loaded.",
    "VINF_PDM_ALREADY_LOADED",
     VINF_PDM_ALREADY_LOADED }, 
  { "The name of the module clashed with an existing module.",
    "The name of the module clashed with an existing module.",
    "VERR_PDM_MODULE_NAME_CLASH",
     VERR_PDM_MODULE_NAME_CLASH }, 
  { "Couldn't find any export for registration of drivers/devices.",
    "Couldn't find any export for registration of drivers/devices.",
    "VERR_PDM_NO_REGISTRATION_EXPORT",
     VERR_PDM_NO_REGISTRATION_EXPORT }, 
  { "A module name is too long.",
    "A module name is too long.",
    "VERR_PDM_MODULE_NAME_TOO_LONG",
     VERR_PDM_MODULE_NAME_TOO_LONG }, 
  { "Driver name clash.",
    "Driver name clash. Another driver with the same name as the one begin registred exists.",
    "VERR_PDM_DRIVER_NAME_CLASH",
     VERR_PDM_DRIVER_NAME_CLASH }, 
  { "The version of the driver registration structure is unknown to this VBox version.",
    "The version of the driver registration structure is unknown to this VBox version. Either mixing incompatible versions or the structure isn't correctly initialized.",
    "VERR_PDM_UNKNOWN_DRVREG_VERSION",
     VERR_PDM_UNKNOWN_DRVREG_VERSION }, 
  { "Invalid entry in the driver registration structure.",
    "Invalid entry in the driver registration structure.",
    "VERR_PDM_INVALID_DRIVER_REGISTRATION",
     VERR_PDM_INVALID_DRIVER_REGISTRATION }, 
  { "Invalid host bit mask.",
    "Invalid host bit mask.",
    "VERR_PDM_INVALID_DRIVER_HOST_BITS",
     VERR_PDM_INVALID_DRIVER_HOST_BITS }, 
  { "Not possible to detach a driver because the above driver/device doesn't support it.",
    "Not possible to detach a driver because the above driver/device doesn't support it. The above entity doesn't implement the pfnDetach call.",
    "VERR_PDM_DRIVER_DETACH_NOT_POSSIBLE",
     VERR_PDM_DRIVER_DETACH_NOT_POSSIBLE }, 
  { "No PCI Bus is available to register the device with.",
    "No PCI Bus is available to register the device with. This is usually a misconfiguration or in rare cases a buggy pci device.",
    "VERR_PDM_NO_PCI_BUS",
     VERR_PDM_NO_PCI_BUS }, 
  { "The device is not a registered PCI device and thus cannot perform any PCI operations.",
    "The device is not a registered PCI device and thus cannot perform any PCI operations. The device forgot to register it self.",
    "VERR_PDM_NOT_PCI_DEVICE",
     VERR_PDM_NOT_PCI_DEVICE }, 
  { "The version of the device registration structure is unknown to this VBox version.",
    "The version of the device registration structure is unknown to this VBox version. Either mixing incompatible versions or the structure isn't correctly initialized.",
    "VERR_PDM_UNKNOWN_DEVREG_VERSION",
     VERR_PDM_UNKNOWN_DEVREG_VERSION }, 
  { "Invalid entry in the device registration structure.",
    "Invalid entry in the device registration structure.",
    "VERR_PDM_INVALID_DEVICE_REGISTRATION",
     VERR_PDM_INVALID_DEVICE_REGISTRATION }, 
  { "Invalid host bit mask.",
    "Invalid host bit mask.",
    "VERR_PDM_INVALID_DEVICE_GUEST_BITS",
     VERR_PDM_INVALID_DEVICE_GUEST_BITS }, 
  { "The guest bit mask didn't match the guest being loaded.",
    "The guest bit mask didn't match the guest being loaded.",
    "VERR_PDM_INVALID_DEVICE_HOST_BITS",
     VERR_PDM_INVALID_DEVICE_HOST_BITS }, 
  { "Device name clash.",
    "Device name clash. Another device with the same name as the one begin registred exists.",
    "VERR_PDM_DEVICE_NAME_CLASH",
     VERR_PDM_DEVICE_NAME_CLASH }, 
  { "The device wasn't found.",
    "The device wasn't found. There was no registered device by that name.",
    "VERR_PDM_DEVICE_NOT_FOUND",
     VERR_PDM_DEVICE_NOT_FOUND }, 
  { "The device instance was not found.",
    "The device instance was not found.",
    "VERR_PDM_DEVICE_INSTANCE_NOT_FOUND",
     VERR_PDM_DEVICE_INSTANCE_NOT_FOUND }, 
  { "The device instance have no base interface.",
    "The device instance have no base interface.",
    "VERR_PDM_DEVICE_INSTANCE_NO_IBASE",
     VERR_PDM_DEVICE_INSTANCE_NO_IBASE }, 
  { "The device instance have no such logical unit.",
    "The device instance have no such logical unit.",
    "VERR_PDM_DEVICE_INSTANCE_LUN_NOT_FOUND",
     VERR_PDM_DEVICE_INSTANCE_LUN_NOT_FOUND }, 
  { "The driver instance could not be found.",
    "The driver instance could not be found.",
    "VERR_PDM_DRIVER_INSTANCE_NOT_FOUND",
     VERR_PDM_DRIVER_INSTANCE_NOT_FOUND }, 
  { "Logical Unit was not found.",
    "Logical Unit was not found.",
    "VERR_PDM_LUN_NOT_FOUND",
     VERR_PDM_LUN_NOT_FOUND }, 
  { "The Logical Unit was found, but it had no driver attached to it.",
    "The Logical Unit was found, but it had no driver attached to it.",
    "VERR_PDM_NO_DRIVER_ATTACHED_TO_LUN",
     VERR_PDM_NO_DRIVER_ATTACHED_TO_LUN }, 
  { "The Logical Unit was found, but it had no driver attached to it.",
    "The Logical Unit was found, but it had no driver attached to it.",
    "VINF_PDM_NO_DRIVER_ATTACHED_TO_LUN",
     VINF_PDM_NO_DRIVER_ATTACHED_TO_LUN }, 
  { "No PIC device instance is registered with the current VM and thus the PIC operation cannot be performed.",
    "No PIC device instance is registered with the current VM and thus the PIC operation cannot be performed.",
    "VERR_PDM_NO_PIC_INSTANCE",
     VERR_PDM_NO_PIC_INSTANCE }, 
  { "No APIC device instance is registered with the current VM and thus the APIC operation cannot be performed.",
    "No APIC device instance is registered with the current VM and thus the APIC operation cannot be performed.",
    "VERR_PDM_NO_APIC_INSTANCE",
     VERR_PDM_NO_APIC_INSTANCE }, 
  { "No DMAC device instance is registered with the current VM and thus the DMA operation cannot be performed.",
    "No DMAC device instance is registered with the current VM and thus the DMA operation cannot be performed.",
    "VERR_PDM_NO_DMAC_INSTANCE",
     VERR_PDM_NO_DMAC_INSTANCE }, 
  { "No RTC device instance is registered with the current VM and thus the RTC or CMOS operation cannot be performed.",
    "No RTC device instance is registered with the current VM and thus the RTC or CMOS operation cannot be performed.",
    "VERR_PDM_NO_RTC_INSTANCE",
     VERR_PDM_NO_RTC_INSTANCE }, 
  { "Unable to open the host interface due to a sharing violation .",
    "Unable to open the host interface due to a sharing violation .",
    "VERR_PDM_HIF_SHARING_VIOLATION",
     VERR_PDM_HIF_SHARING_VIOLATION }, 
  { "Unable to open the host interface.",
    "Unable to open the host interface.",
    "VERR_PDM_HIF_OPEN_FAILED",
     VERR_PDM_HIF_OPEN_FAILED }, 
  { "The device doesn't support runtime driver attaching.",
    "The device doesn't support runtime driver attaching. The PDMDEVREG::pfnAttach callback function is NULL.",
    "VERR_PDM_DEVICE_NO_RT_ATTACH",
     VERR_PDM_DEVICE_NO_RT_ATTACH }, 
  { "The driver doesn't support runtime driver attaching.",
    "The driver doesn't support runtime driver attaching. The PDMDRVREG::pfnAttach callback function is NULL.",
    "VERR_PDM_DRIVER_NO_RT_ATTACH",
     VERR_PDM_DRIVER_NO_RT_ATTACH }, 
  { "Invalid host interface version.",
    "Invalid host interface version.",
    "VERR_PDM_HIF_INVALID_VERSION",
     VERR_PDM_HIF_INVALID_VERSION }, 
  { "The version of the USB device registration structure is unknown to this VBox version.",
    "The version of the USB device registration structure is unknown to this VBox version. Either mixing incompatible versions or the structure isn't correctly initialized.",
    "VERR_PDM_UNKNOWN_USBREG_VERSION",
     VERR_PDM_UNKNOWN_USBREG_VERSION }, 
  { "Invalid entry in the device registration structure.",
    "Invalid entry in the device registration structure.",
    "VERR_PDM_INVALID_USB_REGISTRATION",
     VERR_PDM_INVALID_USB_REGISTRATION }, 
  { "Driver name clash.",
    "Driver name clash. Another driver with the same name as the one begin registred exists.",
    "VERR_PDM_USB_NAME_CLASH",
     VERR_PDM_USB_NAME_CLASH }, 
  { "The USB hub is already registered.",
    "The USB hub is already registered.",
    "VERR_PDM_USB_HUB_EXISTS",
     VERR_PDM_USB_HUB_EXISTS }, 
  { "Couldn't find any USB hubs to attach the device to.",
    "Couldn't find any USB hubs to attach the device to.",
    "VERR_PDM_NO_USB_HUBS",
     VERR_PDM_NO_USB_HUBS }, 
  { "Couldn't find any free USB ports to attach the device to.",
    "Couldn't find any free USB ports to attach the device to.",
    "VERR_PDM_NO_USB_PORTS",
     VERR_PDM_NO_USB_PORTS }, 
  { "Couldn't find the USB Proxy device.",
    "Couldn't find the USB Proxy device. Using OSE?.",
    "VERR_PDM_NO_USBPROXY",
     VERR_PDM_NO_USBPROXY }, 
  { "The async completion template is still used.",
    "The async completion template is still used.",
    "VERR_PDM_ASYNC_TEMPLATE_BUSY",
     VERR_PDM_ASYNC_TEMPLATE_BUSY }, 
  { "The async completion task is already suspended.",
    "The async completion task is already suspended.",
    "VERR_PDM_ASYNC_COMPLETION_ALREADY_SUSPENDED",
     VERR_PDM_ASYNC_COMPLETION_ALREADY_SUSPENDED }, 
  { "The async completion task is not suspended.",
    "The async completion task is not suspended.",
    "VERR_PDM_ASYNC_COMPLETION_NOT_SUSPENDED",
     VERR_PDM_ASYNC_COMPLETION_NOT_SUSPENDED }, 
  { "The driver properties were invalid, and as a consequence construction failed.",
    "The driver properties were invalid, and as a consequence construction failed. Caused my unusable media or similar problems.",
    "VERR_PDM_DRIVER_INVALID_PROPERTIES",
     VERR_PDM_DRIVER_INVALID_PROPERTIES }, 
  { "Too many instances of a device.",
    "Too many instances of a device.",
    "VERR_PDM_TOO_MANY_DEVICE_INSTANCES",
     VERR_PDM_TOO_MANY_DEVICE_INSTANCES }, 
  { "Too many instances of a driver.",
    "Too many instances of a driver.",
    "VERR_PDM_TOO_MANY_DRIVER_INSTANCES",
     VERR_PDM_TOO_MANY_DRIVER_INSTANCES }, 
  { "Too many instances of a usb device.",
    "Too many instances of a usb device.",
    "VERR_PDM_TOO_MANY_USB_DEVICE_INSTANCES",
     VERR_PDM_TOO_MANY_USB_DEVICE_INSTANCES }, 
  { "Too many instances of a usb device.",
    "Too many instances of a usb device.",
    "VERR_PDM_TOO_MANY_USB_DEVICE_INSTANCES",
     VERR_PDM_TOO_MANY_USB_DEVICE_INSTANCES }, 
  { "The device instance structure version has changed.",
    "The device instance structure version has changed.\nIf you have upgraded VirtualBox recently, please make sure you have terminated all VMs and upgraded any extension packs. If this error persists, try re-installing VirtualBox.",
    "VERR_PDM_DEVINS_VERSION_MISMATCH",
     VERR_PDM_DEVINS_VERSION_MISMATCH }, 
  { "The device helper structure version has changed.",
    "The device helper structure version has changed.\nIf you have upgraded VirtualBox recently, please make sure you have terminated all VMs and upgraded any extension packs. If this error persists, try re-installing VirtualBox.",
    "VERR_PDM_DEVHLPR3_VERSION_MISMATCH",
     VERR_PDM_DEVHLPR3_VERSION_MISMATCH }, 
  { "The USB device instance structure version has changed.",
    "The USB device instance structure version has changed.\nIf you have upgraded VirtualBox recently, please make sure you have terminated all VMs and upgraded any extension packs. If this error persists, try re-installing VirtualBox.",
    "VERR_PDM_USBINS_VERSION_MISMATCH",
     VERR_PDM_USBINS_VERSION_MISMATCH }, 
  { "The USB device helper structure version has changed.",
    "The USB device helper structure version has changed.\nIf you have upgraded VirtualBox recently, please make sure you have terminated all VMs and upgraded any extension packs. If this error persists, try re-installing VirtualBox.",
    "VERR_PDM_USBHLPR3_VERSION_MISMATCH",
     VERR_PDM_USBHLPR3_VERSION_MISMATCH }, 
  { "The driver instance structure version has changed.",
    "The driver instance structure version has changed.\nIf you have upgraded VirtualBox recently, please make sure you have terminated all VMs and upgraded any extension packs. If this error persists, try re-installing VirtualBox.",
    "VERR_PDM_DRVINS_VERSION_MISMATCH",
     VERR_PDM_DRVINS_VERSION_MISMATCH }, 
  { "The driver helper structure version has changed.",
    "The driver helper structure version has changed.\nIf you have upgraded VirtualBox recently, please make sure you have terminated all VMs and upgraded any extension packs. If this error persists, try re-installing VirtualBox.",
    "VERR_PDM_DRVHLPR3_VERSION_MISMATCH",
     VERR_PDM_DRVHLPR3_VERSION_MISMATCH }, 
  { "Generic device structure version mismatch.",
    "Generic device structure version mismatch.\nIf you have upgraded VirtualBox recently, please make sure you have terminated all VMs and upgraded any extension packs. If this error persists, try re-installing VirtualBox.",
    "VERR_PDM_DEVICE_VERSION_MISMATCH",
     VERR_PDM_DEVICE_VERSION_MISMATCH }, 
  { "Generic USB device structure version mismatch.",
    "Generic USB device structure version mismatch.\nIf you have upgraded VirtualBox recently, please make sure you have terminated all VMs and upgraded any extension packs. If this error persists, try re-installing VirtualBox.",
    "VERR_PDM_USBDEV_VERSION_MISMATCH",
     VERR_PDM_USBDEV_VERSION_MISMATCH }, 
  { "Generic driver structure version mismatch.",
    "Generic driver structure version mismatch.\nIf you have upgraded VirtualBox recently, please make sure you have terminated all VMs and upgraded any extension packs. If this error persists, try re-installing VirtualBox.",
    "VERR_PDM_DRIVER_VERSION_MISMATCH",
     VERR_PDM_DRIVER_VERSION_MISMATCH }, 
  { "PDMVMMDevHeapR3ToGCPhys failure.",
    "PDMVMMDevHeapR3ToGCPhys failure.",
    "VERR_PDM_DEV_HEAP_R3_TO_GCPHYS",
     VERR_PDM_DEV_HEAP_R3_TO_GCPHYS }, 
  { "A legacy device isn't implementing the HPET notification interface.",
    "A legacy device isn't implementing the HPET notification interface.",
    "VERR_PDM_HPET_LEGACY_NOTIFY_MISSING",
     VERR_PDM_HPET_LEGACY_NOTIFY_MISSING }, 
  { "Internal processing error in the critical section code.",
    "Internal processing error in the critical section code.",
    "VERR_PDM_CRITSECT_IPE",
     VERR_PDM_CRITSECT_IPE }, 
  { "The critical section being deleted was not found.",
    "The critical section being deleted was not found.",
    "VERR_PDM_CRITSECT_NOT_FOUND",
     VERR_PDM_CRITSECT_NOT_FOUND }, 
  { "A PDMThread API was called by the wrong thread.",
    "A PDMThread API was called by the wrong thread.",
    "VERR_PDM_THREAD_INVALID_CALLER",
     VERR_PDM_THREAD_INVALID_CALLER }, 
  { "Internal processing error #1 in the PDM Thread code.",
    "Internal processing error #1 in the PDM Thread code.",
    "VERR_PDM_THREAD_IPE_1",
     VERR_PDM_THREAD_IPE_1 }, 
  { "Internal processing error #2 in the PDM Thread code.",
    "Internal processing error #2 in the PDM Thread code.",
    "VERR_PDM_THREAD_IPE_2",
     VERR_PDM_THREAD_IPE_2 }, 
  { "Only one PCI function is supported per PDM device.",
    "Only one PCI function is supported per PDM device.",
    "VERR_PDM_ONE_PCI_FUNCTION_PER_DEVICE",
     VERR_PDM_ONE_PCI_FUNCTION_PER_DEVICE }, 
  { "Bad PCI configuration.",
    "Bad PCI configuration.",
    "VERR_PDM_BAD_PCI_CONFIG",
     VERR_PDM_BAD_PCI_CONFIG }, 
  { "Internal processing error # in the PDM device code.",
    "Internal processing error # in the PDM device code.",
    "VERR_PDM_DEV_IPE_1",
     VERR_PDM_DEV_IPE_1 }, 
  { "Misconfigured driver chain transformation.",
    "Misconfigured driver chain transformation.",
    "VERR_PDM_MISCONFIGURED_DRV_TRANSFORMATION",
     VERR_PDM_MISCONFIGURED_DRV_TRANSFORMATION }, 
  { "The driver is already removed, not more transformations possible (at present).",
    "The driver is already removed, not more transformations possible (at present).",
    "VERR_PDM_CANNOT_TRANSFORM_REMOVED_DRIVER",
     VERR_PDM_CANNOT_TRANSFORM_REMOVED_DRIVER }, 
  { "Requested service does not exist.",
    "Requested service does not exist.",
    "VERR_HGCM_SERVICE_NOT_FOUND",
     VERR_HGCM_SERVICE_NOT_FOUND }, 
  { "Service rejected client connection.",
    "Service rejected client connection.",
    "VINF_HGCM_CLIENT_REJECTED",
     VINF_HGCM_CLIENT_REJECTED }, 
  { "Command address is invalid.",
    "Command address is invalid.",
    "VERR_HGCM_INVALID_CMD_ADDRESS",
     VERR_HGCM_INVALID_CMD_ADDRESS }, 
  { "Service will execute the command in background.",
    "Service will execute the command in background.",
    "VINF_HGCM_ASYNC_EXECUTE",
     VINF_HGCM_ASYNC_EXECUTE }, 
  { "HGCM could not perform requested operation because of an internal error.",
    "HGCM could not perform requested operation because of an internal error.",
    "VERR_HGCM_INTERNAL",
     VERR_HGCM_INTERNAL }, 
  { "Invalid HGCM client id.",
    "Invalid HGCM client id.",
    "VERR_HGCM_INVALID_CLIENT_ID",
     VERR_HGCM_INVALID_CLIENT_ID }, 
  { "The HGCM is saving state.",
    "The HGCM is saving state.",
    "VINF_HGCM_SAVE_STATE",
     VINF_HGCM_SAVE_STATE }, 
  { "Requested service already exists.",
    "Requested service already exists.",
    "VERR_HGCM_SERVICE_EXISTS",
     VERR_HGCM_SERVICE_EXISTS }, 
  { "Failed to find the DNS configured for this machine.",
    "Failed to find the DNS configured for this machine.",
    "VINF_NAT_DNS",
     VINF_NAT_DNS }, 
  { "Failed to convert the specified Guest IP to a binary IP address.",
    "Failed to convert the specified Guest IP to a binary IP address. Malformed input.",
    "VERR_NAT_REDIR_GUEST_IP",
     VERR_NAT_REDIR_GUEST_IP }, 
  { "Failed while setting up a redirector rule.",
    "Failed while setting up a redirector rule. There probably is a conflict between the rule and some existing service on the computer.",
    "VERR_NAT_REDIR_SETUP",
     VERR_NAT_REDIR_SETUP }, 
  { "The Host Interface Networking init program failed.",
    "The Host Interface Networking init program failed.",
    "VERR_HOSTIF_INIT_FAILED",
     VERR_HOSTIF_INIT_FAILED }, 
  { "The Host Interface Networking device name is too long.",
    "The Host Interface Networking device name is too long.",
    "VERR_HOSTIF_DEVICE_NAME_TOO_LONG",
     VERR_HOSTIF_DEVICE_NAME_TOO_LONG }, 
  { "The Host Interface Networking name config IOCTL call failed.",
    "The Host Interface Networking name config IOCTL call failed.",
    "VERR_HOSTIF_IOCTL",
     VERR_HOSTIF_IOCTL }, 
  { "Failed to make the Host Interface Networking handle non-blocking.",
    "Failed to make the Host Interface Networking handle non-blocking.",
    "VERR_HOSTIF_BLOCKING",
     VERR_HOSTIF_BLOCKING }, 
  { "If a Host Interface Networking filehandle was specified it's not allowed to have any init or term programs.",
    "If a Host Interface Networking filehandle was specified it's not allowed to have any init or term programs.",
    "VERR_HOSTIF_FD_AND_INIT_TERM",
     VERR_HOSTIF_FD_AND_INIT_TERM }, 
  { "The Host Interface Networking terminate program failed.",
    "The Host Interface Networking terminate program failed.",
    "VERR_HOSTIF_TERM_FAILED",
     VERR_HOSTIF_TERM_FAILED }, 
  { "Invalid image type.",
    "Invalid image type.",
    "VERR_VD_INVALID_TYPE",
     VERR_VD_INVALID_TYPE }, 
  { "Operation can't be done in current HDD container state.",
    "Operation can't be done in current HDD container state.",
    "VERR_VD_INVALID_STATE",
     VERR_VD_INVALID_STATE }, 
  { "Configuration value not found.",
    "Configuration value not found.",
    "VERR_VD_VALUE_NOT_FOUND",
     VERR_VD_VALUE_NOT_FOUND }, 
  { "Virtual HDD is not opened.",
    "Virtual HDD is not opened.",
    "VERR_VD_NOT_OPENED",
     VERR_VD_NOT_OPENED }, 
  { "Requested image is not opened.",
    "Requested image is not opened.",
    "VERR_VD_IMAGE_NOT_FOUND",
     VERR_VD_IMAGE_NOT_FOUND }, 
  { "Image is read-only.",
    "Image is read-only.",
    "VERR_VD_IMAGE_READ_ONLY",
     VERR_VD_IMAGE_READ_ONLY }, 
  { "Geometry hasn't been set.",
    "Geometry hasn't been set.",
    "VERR_VD_GEOMETRY_NOT_SET",
     VERR_VD_GEOMETRY_NOT_SET }, 
  { "No data for this block in image.",
    "No data for this block in image.",
    "VERR_VD_BLOCK_FREE",
     VERR_VD_BLOCK_FREE }, 
  { "Differencing and parent images can't be used together due to UUID.",
    "Differencing and parent images can't be used together due to UUID.",
    "VERR_VD_UUID_MISMATCH",
     VERR_VD_UUID_MISMATCH }, 
  { "Asynchronous I/O request finished.",
    "Asynchronous I/O request finished.",
    "VINF_VD_ASYNC_IO_FINISHED",
     VINF_VD_ASYNC_IO_FINISHED }, 
  { "Asynchronous I/O is not finished yet.",
    "Asynchronous I/O is not finished yet.",
    "VERR_VD_ASYNC_IO_IN_PROGRESS",
     VERR_VD_ASYNC_IO_IN_PROGRESS }, 
  { "The image is too small or too large for this format.",
    "The image is too small or too large for this format.",
    "VERR_VD_INVALID_SIZE",
     VERR_VD_INVALID_SIZE }, 
  { "Generic: Invalid image file header.",
    "Generic: Invalid image file header. Use this for plugins.",
    "VERR_VD_GEN_INVALID_HEADER",
     VERR_VD_GEN_INVALID_HEADER }, 
  { "VDI: Invalid image file header.",
    "VDI: Invalid image file header.",
    "VERR_VD_VDI_INVALID_HEADER",
     VERR_VD_VDI_INVALID_HEADER }, 
  { "VDI: Invalid image file header: invalid signature.",
    "VDI: Invalid image file header: invalid signature.",
    "VERR_VD_VDI_INVALID_SIGNATURE",
     VERR_VD_VDI_INVALID_SIGNATURE }, 
  { "VDI: Invalid image file header: invalid version.",
    "VDI: Invalid image file header: invalid version.",
    "VERR_VD_VDI_UNSUPPORTED_VERSION",
     VERR_VD_VDI_UNSUPPORTED_VERSION }, 
  { "Comment string is too long.",
    "Comment string is too long.",
    "VERR_VD_VDI_COMMENT_TOO_LONG",
     VERR_VD_VDI_COMMENT_TOO_LONG }, 
  { "VMDK: Invalid image file header.",
    "VMDK: Invalid image file header.",
    "VERR_VD_VMDK_INVALID_HEADER",
     VERR_VD_VMDK_INVALID_HEADER }, 
  { "VMDK: Invalid image file header: invalid version.",
    "VMDK: Invalid image file header: invalid version.",
    "VERR_VD_VMDK_UNSUPPORTED_VERSION",
     VERR_VD_VMDK_UNSUPPORTED_VERSION }, 
  { "VMDK: Image property not found.",
    "VMDK: Image property not found.",
    "VERR_VD_VMDK_VALUE_NOT_FOUND",
     VERR_VD_VMDK_VALUE_NOT_FOUND }, 
  { "VMDK: Operation can't be done in current image state.",
    "VMDK: Operation can't be done in current image state.",
    "VERR_VD_VMDK_INVALID_STATE",
     VERR_VD_VMDK_INVALID_STATE }, 
  { "VMDK: Format is invalid/inconsistent.",
    "VMDK: Format is invalid/inconsistent.",
    "VERR_VD_VMDK_INVALID_FORMAT",
     VERR_VD_VMDK_INVALID_FORMAT }, 
  { "VMDK: Invalid write position.",
    "VMDK: Invalid write position.",
    "VERR_VD_VMDK_INVALID_WRITE",
     VERR_VD_VMDK_INVALID_WRITE }, 
  { "iSCSI: Invalid header, i.",
    "iSCSI: Invalid header, i.e. dummy for validity check.",
    "VERR_VD_ISCSI_INVALID_HEADER",
     VERR_VD_ISCSI_INVALID_HEADER }, 
  { "iSCSI: Configuration value is unknown.",
    "iSCSI: Configuration value is unknown. This indicates misconfiguration.",
    "VERR_VD_ISCSI_UNKNOWN_CFG_VALUES",
     VERR_VD_ISCSI_UNKNOWN_CFG_VALUES }, 
  { "iSCSI: Interface is unknown.",
    "iSCSI: Interface is unknown. This indicates misconfiguration.",
    "VERR_VD_ISCSI_UNKNOWN_INTERFACE",
     VERR_VD_ISCSI_UNKNOWN_INTERFACE }, 
  { "iSCSI: Operation can't be done in current image state.",
    "iSCSI: Operation can't be done in current image state.",
    "VERR_VD_ISCSI_INVALID_STATE",
     VERR_VD_ISCSI_INVALID_STATE }, 
  { "iSCSI: Invalid device type (not a disk).",
    "iSCSI: Invalid device type (not a disk).",
    "VERR_VD_ISCSI_INVALID_TYPE",
     VERR_VD_ISCSI_INVALID_TYPE }, 
  { "VHD: Invalid image file header.",
    "VHD: Invalid image file header.",
    "VERR_VD_VHD_INVALID_HEADER",
     VERR_VD_VHD_INVALID_HEADER }, 
  { "Parallels HDD: Invalid image file header.",
    "Parallels HDD: Invalid image file header.",
    "VERR_VD_PARALLELS_INVALID_HEADER",
     VERR_VD_PARALLELS_INVALID_HEADER }, 
  { "DMG: Invalid image file header.",
    "DMG: Invalid image file header.",
    "VERR_VD_DMG_INVALID_HEADER",
     VERR_VD_DMG_INVALID_HEADER }, 
  { "Raw: Invalid image file header.",
    "Raw: Invalid image file header.",
    "VERR_VD_RAW_INVALID_HEADER",
     VERR_VD_RAW_INVALID_HEADER }, 
  { "Raw: Invalid image file type.",
    "Raw: Invalid image file type.",
    "VERR_VD_RAW_INVALID_TYPE",
     VERR_VD_RAW_INVALID_TYPE }, 
  { "The backend needs more metadata before it can continue.",
    "The backend needs more metadata before it can continue.",
    "VERR_VD_NOT_ENOUGH_METADATA",
     VERR_VD_NOT_ENOUGH_METADATA }, 
  { "Halt the current I/O context until further notification from the backend.",
    "Halt the current I/O context until further notification from the backend.",
    "VERR_VD_IOCTX_HALT",
     VERR_VD_IOCTX_HALT }, 
  { "The disk has a cache attached already.",
    "The disk has a cache attached already.",
    "VERR_VD_CACHE_ALREADY_EXISTS",
     VERR_VD_CACHE_ALREADY_EXISTS }, 
  { "There is no cache attached to the disk.",
    "There is no cache attached to the disk.",
    "VERR_VD_CACHE_NOT_FOUND",
     VERR_VD_CACHE_NOT_FOUND }, 
  { "The cache is not up to date with the image.",
    "The cache is not up to date with the image.",
    "VERR_VD_CACHE_NOT_UP_TO_DATE",
     VERR_VD_CACHE_NOT_UP_TO_DATE }, 
  { "Library was not initialized.",
    "Library was not initialized.",
    "VERR_VBGL_NOT_INITIALIZED",
     VERR_VBGL_NOT_INITIALIZED }, 
  { "Virtual address was not allocated by the library.",
    "Virtual address was not allocated by the library.",
    "VERR_VBGL_INVALID_ADDR",
     VERR_VBGL_INVALID_ADDR }, 
  { "IOCtl to VBoxGuest driver failed.",
    "IOCtl to VBoxGuest driver failed.",
    "VERR_VBGL_IOCTL_FAILED",
     VERR_VBGL_IOCTL_FAILED }, 
  { "No available ports on the hub.",
    "No available ports on the hub. This error is returned when a device is attempted created and/or attached to a hub which is out of ports.",
    "VERR_VUSB_NO_PORTS",
     VERR_VUSB_NO_PORTS }, 
  { "The requested operation cannot be performed on a detached USB device.",
    "The requested operation cannot be performed on a detached USB device.",
    "VERR_VUSB_DEVICE_NOT_ATTACHED",
     VERR_VUSB_DEVICE_NOT_ATTACHED }, 
  { "Failed to allocate memory for a URB.",
    "Failed to allocate memory for a URB.",
    "VERR_VUSB_NO_URB_MEMORY",
     VERR_VUSB_NO_URB_MEMORY }, 
  { "General failure during URB queuing.",
    "General failure during URB queuing. This will go away when the queueing gets proper status code handling.",
    "VERR_VUSB_FAILED_TO_QUEUE_URB",
     VERR_VUSB_FAILED_TO_QUEUE_URB }, 
  { "Device creation failed because the USB device name was not found.",
    "Device creation failed because the USB device name was not found.",
    "VERR_VUSB_DEVICE_NAME_NOT_FOUND",
     VERR_VUSB_DEVICE_NAME_NOT_FOUND }, 
  { "Not permitted to open the USB device.",
    "Not permitted to open the USB device. The user doesn't have access to the device in the usbfs, check the mount options.",
    "VERR_VUSB_USBFS_PERMISSION",
     VERR_VUSB_USBFS_PERMISSION }, 
  { "The requested operation cannot be performed because the device is currently being reset.",
    "The requested operation cannot be performed because the device is currently being reset.",
    "VERR_VUSB_DEVICE_IS_RESETTING",
     VERR_VUSB_DEVICE_IS_RESETTING }, 
  { "The requested operation cannot be performed because the device is currently suspended.",
    "The requested operation cannot be performed because the device is currently suspended.",
    "VERR_VUSB_DEVICE_IS_SUSPENDED",
     VERR_VUSB_DEVICE_IS_SUSPENDED }, 
  { "Not permitted to open the USB device.",
    "Not permitted to open the USB device. The user doesn't have access to the device node, check group memberships.",
    "VERR_VUSB_USB_DEVICE_PERMISSION",
     VERR_VUSB_USB_DEVICE_PERMISSION }, 
  { "One of the custom modes was incorrect.",
    "One of the custom modes was incorrect. The format or bit count of the custom mode value is invalid.",
    "VERR_VGA_INVALID_CUSTOM_MODE",
     VERR_VGA_INVALID_CUSTOM_MODE }, 
  { "The display connector is resizing.",
    "The display connector is resizing.",
    "VINF_VGA_RESIZE_IN_PROGRESS",
     VINF_VGA_RESIZE_IN_PROGRESS }, 
  { "The networking interface to filter was not found.",
    "The networking interface to filter was not found.",
    "VERR_INTNET_FLT_IF_NOT_FOUND",
     VERR_INTNET_FLT_IF_NOT_FOUND }, 
  { "The networking interface to filter was busy (used by someone).",
    "The networking interface to filter was busy (used by someone).",
    "VERR_INTNET_FLT_IF_BUSY",
     VERR_INTNET_FLT_IF_BUSY }, 
  { "Failed to create or connect to a networking interface filter.",
    "Failed to create or connect to a networking interface filter.",
    "VERR_INTNET_FLT_IF_FAILED",
     VERR_INTNET_FLT_IF_FAILED }, 
  { "The network already exists with a different trunk configuration.",
    "The network already exists with a different trunk configuration.",
    "VERR_INTNET_INCOMPATIBLE_TRUNK",
     VERR_INTNET_INCOMPATIBLE_TRUNK }, 
  { "The network already exists with a different security profile (restricted / public).",
    "The network already exists with a different security profile (restricted / public).",
    "VERR_INTNET_INCOMPATIBLE_FLAGS",
     VERR_INTNET_INCOMPATIBLE_FLAGS }, 
  { "Failed to create a virtual network interface instance.",
    "Failed to create a virtual network interface instance.",
    "VERR_INTNET_FLT_VNIC_CREATE_FAILED",
     VERR_INTNET_FLT_VNIC_CREATE_FAILED }, 
  { "The component factory was not found.",
    "The component factory was not found.",
    "VERR_SUPDRV_COMPONENT_NOT_FOUND",
     VERR_SUPDRV_COMPONENT_NOT_FOUND }, 
  { "The component factories do not support the requested interface.",
    "The component factories do not support the requested interface.",
    "VERR_SUPDRV_INTERFACE_NOT_SUPPORTED",
     VERR_SUPDRV_INTERFACE_NOT_SUPPORTED }, 
  { "The service module was not found.",
    "The service module was not found.",
    "VERR_SUPDRV_SERVICE_NOT_FOUND",
     VERR_SUPDRV_SERVICE_NOT_FOUND }, 
  { "The host kernel is too old.",
    "The host kernel is too old.",
    "VERR_SUPDRV_KERNEL_TOO_OLD_FOR_VTX",
     VERR_SUPDRV_KERNEL_TOO_OLD_FOR_VTX }, 
  { "The specified path was not absolute (hardening).",
    "The specified path was not absolute (hardening).",
    "VERR_SUPLIB_PATH_NOT_ABSOLUTE",
     VERR_SUPLIB_PATH_NOT_ABSOLUTE }, 
  { "The specified path was not clean (hardening).",
    "The specified path was not clean (hardening).",
    "VERR_SUPLIB_PATH_NOT_CLEAN",
     VERR_SUPLIB_PATH_NOT_CLEAN }, 
  { "The specified path is too long (hardening).",
    "The specified path is too long (hardening).",
    "VERR_SUPLIB_PATH_TOO_LONG",
     VERR_SUPLIB_PATH_TOO_LONG }, 
  { "The specified path is too short (hardening).",
    "The specified path is too short (hardening).",
    "VERR_SUPLIB_PATH_TOO_SHORT",
     VERR_SUPLIB_PATH_TOO_SHORT }, 
  { "The specified path has too many components (hardening).",
    "The specified path has too many components (hardening).",
    "VERR_SUPLIB_PATH_TOO_MANY_COMPONENTS",
     VERR_SUPLIB_PATH_TOO_MANY_COMPONENTS }, 
  { "The specified path is a root path (hardening).",
    "The specified path is a root path (hardening).",
    "VERR_SUPLIB_PATH_IS_ROOT",
     VERR_SUPLIB_PATH_IS_ROOT }, 
  { "Failed to enumerate directory (hardening).",
    "Failed to enumerate directory (hardening).",
    "VERR_SUPLIB_DIR_ENUM_FAILED",
     VERR_SUPLIB_DIR_ENUM_FAILED }, 
  { "Failed to stat a file/dir during enumeration (hardening).",
    "Failed to stat a file/dir during enumeration (hardening).",
    "VERR_SUPLIB_STAT_ENUM_FAILED",
     VERR_SUPLIB_STAT_ENUM_FAILED }, 
  { "Failed to stat a file/dir (hardening).",
    "Failed to stat a file/dir (hardening).",
    "VERR_SUPLIB_STAT_FAILED",
     VERR_SUPLIB_STAT_FAILED }, 
  { "Failed to fstat a native handle (hardening).",
    "Failed to fstat a native handle (hardening).",
    "VERR_SUPLIB_FSTAT_FAILED",
     VERR_SUPLIB_FSTAT_FAILED }, 
  { "Found an illegal symbolic link (hardening).",
    "Found an illegal symbolic link (hardening).",
    "VERR_SUPLIB_SYMLINKS_ARE_NOT_PERMITTED",
     VERR_SUPLIB_SYMLINKS_ARE_NOT_PERMITTED }, 
  { "Found something which isn't a file nor a directory (hardening).",
    "Found something which isn't a file nor a directory (hardening).",
    "VERR_SUPLIB_NOT_DIR_NOT_FILE",
     VERR_SUPLIB_NOT_DIR_NOT_FILE }, 
  { "The specified path is a directory and not a file (hardening).",
    "The specified path is a directory and not a file (hardening).",
    "VERR_SUPLIB_IS_DIRECTORY",
     VERR_SUPLIB_IS_DIRECTORY }, 
  { "The specified path is a file and not a directory (hardening).",
    "The specified path is a file and not a directory (hardening).",
    "VERR_SUPLIB_IS_FILE",
     VERR_SUPLIB_IS_FILE }, 
  { "The path is not the same object as the native handle (hardening).",
    "The path is not the same object as the native handle (hardening).",
    "VERR_SUPLIB_NOT_SAME_OBJECT",
     VERR_SUPLIB_NOT_SAME_OBJECT }, 
  { "The owner is not root (hardening).",
    "The owner is not root (hardening).",
    "VERR_SUPLIB_OWNER_NOT_ROOT",
     VERR_SUPLIB_OWNER_NOT_ROOT }, 
  { "The group is a non-system group and it has write access (hardening).",
    "The group is a non-system group and it has write access (hardening).",
    "VERR_SUPLIB_WRITE_NON_SYS_GROUP",
     VERR_SUPLIB_WRITE_NON_SYS_GROUP }, 
  { "The file or directory is world writable (hardening).",
    "The file or directory is world writable (hardening).",
    "VERR_SUPLIB_WORLD_WRITABLE",
     VERR_SUPLIB_WORLD_WRITABLE }, 
  { "The argv[0] of an internal application does not match the executable image path (hardening).",
    "The argv[0] of an internal application does not match the executable image path (hardening).",
    "VERR_SUPLIB_INVALID_ARGV0_INTERNAL",
     VERR_SUPLIB_INVALID_ARGV0_INTERNAL }, 
  { "The internal application does not reside in the correct place (hardening).",
    "The internal application does not reside in the correct place (hardening).",
    "VERR_SUPLIB_INVALID_INTERNAL_APP_DIR",
     VERR_SUPLIB_INVALID_INTERNAL_APP_DIR }, 
  { "The GMM is out of pages and needs to be give another chunk of user memory that it can lock down and borrow pages from.",
    "The GMM is out of pages and needs to be give another chunk of user memory that it can lock down and borrow pages from.",
    "VERR_GMM_SEED_ME",
     VERR_GMM_SEED_ME }, 
  { "Unable to allocate more pages from the host system.",
    "Unable to allocate more pages from the host system.",
    "VERR_GMM_OUT_OF_MEMORY",
     VERR_GMM_OUT_OF_MEMORY }, 
  { "Hit the global allocation limit.",
    "Hit the global allocation limit. If you know there is still sufficient memory available, try raising the limit.",
    "VERR_GMM_HIT_GLOBAL_LIMIT",
     VERR_GMM_HIT_GLOBAL_LIMIT }, 
  { "Hit the a VM account limit.",
    "Hit the a VM account limit.",
    "VERR_GMM_HIT_VM_ACCOUNT_LIMIT",
     VERR_GMM_HIT_VM_ACCOUNT_LIMIT }, 
  { "Attempt to free more memory than what was previously allocated.",
    "Attempt to free more memory than what was previously allocated.",
    "VERR_GMM_ATTEMPT_TO_FREE_TOO_MUCH",
     VERR_GMM_ATTEMPT_TO_FREE_TOO_MUCH }, 
  { "Attempted to report too many pages as deflated.",
    "Attempted to report too many pages as deflated.",
    "VERR_GMM_ATTEMPT_TO_DEFLATE_TOO_MUCH",
     VERR_GMM_ATTEMPT_TO_DEFLATE_TOO_MUCH }, 
  { "The page to be freed or updated was not found.",
    "The page to be freed or updated was not found.",
    "VERR_GMM_PAGE_NOT_FOUND",
     VERR_GMM_PAGE_NOT_FOUND }, 
  { "The specified shared page was not actually private.",
    "The specified shared page was not actually private.",
    "VERR_GMM_PAGE_NOT_PRIVATE",
     VERR_GMM_PAGE_NOT_PRIVATE }, 
  { "The specified shared page was not actually shared.",
    "The specified shared page was not actually shared.",
    "VERR_GMM_PAGE_NOT_SHARED",
     VERR_GMM_PAGE_NOT_SHARED }, 
  { "The page to be freed was already freed.",
    "The page to be freed was already freed.",
    "VERR_GMM_PAGE_ALREADY_FREE",
     VERR_GMM_PAGE_ALREADY_FREE }, 
  { "The page to be updated or freed was noted owned by the caller.",
    "The page to be updated or freed was noted owned by the caller.",
    "VERR_GMM_NOT_PAGE_OWNER",
     VERR_GMM_NOT_PAGE_OWNER }, 
  { "The specified chunk was not found.",
    "The specified chunk was not found.",
    "VERR_GMM_CHUNK_NOT_FOUND",
     VERR_GMM_CHUNK_NOT_FOUND }, 
  { "The chunk has already been mapped into the process.",
    "The chunk has already been mapped into the process.",
    "VERR_GMM_CHUNK_ALREADY_MAPPED",
     VERR_GMM_CHUNK_ALREADY_MAPPED }, 
  { "The chunk to be unmapped isn't actually mapped into the process.",
    "The chunk to be unmapped isn't actually mapped into the process.",
    "VERR_GMM_CHUNK_NOT_MAPPED",
     VERR_GMM_CHUNK_NOT_MAPPED }, 
  { "The chunk has been mapped too many times already (impossible).",
    "The chunk has been mapped too many times already (impossible).",
    "VERR_GMM_TOO_MANY_CHUNK_MAPPINGS",
     VERR_GMM_TOO_MANY_CHUNK_MAPPINGS }, 
  { "The reservation or reservation update was declined - too many VMs, too little memory, and/or too low GMM configuration.",
    "The reservation or reservation update was declined - too many VMs, too little memory, and/or too low GMM configuration.",
    "VERR_GMM_MEMORY_RESERVATION_DECLINED",
     VERR_GMM_MEMORY_RESERVATION_DECLINED }, 
  { "A GMM sanity check failed.",
    "A GMM sanity check failed.",
    "VERR_GMM_IS_NOT_SANE",
     VERR_GMM_IS_NOT_SANE }, 
  { "Inserting a new chunk failed.",
    "Inserting a new chunk failed.",
    "VERR_GMM_CHUNK_INSERT",
     VERR_GMM_CHUNK_INSERT }, 
  { "Failed to obtain the GMM instance.",
    "Failed to obtain the GMM instance.",
    "VERR_GMM_INSTANCE",
     VERR_GMM_INSTANCE }, 
  { "Bad mutex semaphore flags.",
    "Bad mutex semaphore flags.",
    "VERR_GMM_MTX_FLAGS",
     VERR_GMM_MTX_FLAGS }, 
  { "Internal processing error in the page allocator.",
    "Internal processing error in the page allocator.",
    "VERR_GMM_ALLOC_PAGES_IPE",
     VERR_GMM_ALLOC_PAGES_IPE }, 
  { "Invalid page count given to GMMR3FreePagesPerform.",
    "Invalid page count given to GMMR3FreePagesPerform.",
    "VERR_GMM_ACTUAL_PAGES_IPE",
     VERR_GMM_ACTUAL_PAGES_IPE }, 
  { "The shared module name is too long.",
    "The shared module name is too long.",
    "VERR_GMM_MODULE_NAME_TOO_LONG",
     VERR_GMM_MODULE_NAME_TOO_LONG }, 
  { "The shared module version string is too long.",
    "The shared module version string is too long.",
    "VERR_GMM_MODULE_VERSION_TOO_LONG",
     VERR_GMM_MODULE_VERSION_TOO_LONG }, 
  { "The shared module has too many regions.",
    "The shared module has too many regions.",
    "VERR_GMM_TOO_MANY_REGIONS",
     VERR_GMM_TOO_MANY_REGIONS }, 
  { "The guest has reported too many modules.",
    "The guest has reported too many modules.",
    "VERR_GMM_TOO_MANY_PER_VM_MODULES",
     VERR_GMM_TOO_MANY_PER_VM_MODULES }, 
  { "The guest has reported too many modules.",
    "The guest has reported too many modules.",
    "VERR_GMM_TOO_MANY_GLOBAL_MODULES",
     VERR_GMM_TOO_MANY_GLOBAL_MODULES }, 
  { "The shared module is already registered.",
    "The shared module is already registered.",
    "VINF_GMM_SHARED_MODULE_ALREADY_REGISTERED",
     VINF_GMM_SHARED_MODULE_ALREADY_REGISTERED }, 
  { "The shared module clashed address wise with a previously registered module.",
    "The shared module clashed address wise with a previously registered module.",
    "VERR_GMM_SHARED_MODULE_ADDRESS_CLASH",
     VERR_GMM_SHARED_MODULE_ADDRESS_CLASH }, 
  { "The shared module was not found.",
    "The shared module was not found.",
    "VERR_GMM_SHARED_MODULE_NOT_FOUND",
     VERR_GMM_SHARED_MODULE_NOT_FOUND }, 
  { "The size of the shared module was out of range.",
    "The size of the shared module was out of range.",
    "VERR_GMM_BAD_SHARED_MODULE_SIZE",
     VERR_GMM_BAD_SHARED_MODULE_SIZE }, 
  { "The size of the one or more regions in the shared module was out of range.",
    "The size of the one or more regions in the shared module was out of range.",
    "VERR_GMM_SHARED_MODULE_BAD_REGIONS_SIZE",
     VERR_GMM_SHARED_MODULE_BAD_REGIONS_SIZE }, 
  { "The GVM is out of VM handle space.",
    "The GVM is out of VM handle space.",
    "VERR_GVM_TOO_MANY_VMS",
     VERR_GVM_TOO_MANY_VMS }, 
  { "The EMT was not blocked at the time of the call.",
    "The EMT was not blocked at the time of the call.",
    "VINF_GVM_NOT_BLOCKED",
     VINF_GVM_NOT_BLOCKED }, 
  { "The EMT was not busy running guest code at the time of the call.",
    "The EMT was not busy running guest code at the time of the call.",
    "VINF_GVM_NOT_BUSY_IN_GC",
     VINF_GVM_NOT_BUSY_IN_GC }, 
  { "RTThreadYield was called during a GVMMR0SchedPoll call.",
    "RTThreadYield was called during a GVMMR0SchedPoll call.",
    "VINF_GVM_YIELDED",
     VINF_GVM_YIELDED }, 
  { "Invalid VMCS index or write to read-only element.",
    "Invalid VMCS index or write to read-only element.",
    "VERR_VMX_INVALID_VMCS_FIELD",
     VERR_VMX_INVALID_VMCS_FIELD }, 
  { "Invalid VMCS pointer.",
    "Invalid VMCS pointer.",
    "VERR_VMX_INVALID_VMCS_PTR",
     VERR_VMX_INVALID_VMCS_PTR }, 
  { "Invalid VMXON pointer.",
    "Invalid VMXON pointer.",
    "VERR_VMX_INVALID_VMXON_PTR",
     VERR_VMX_INVALID_VMXON_PTR }, 
  { "Generic VMX failure.",
    "Generic VMX failure.",
    "VERR_VMX_GENERIC",
     VERR_VMX_GENERIC }, 
  { "Invalid CPU mode for VMX execution.",
    "Invalid CPU mode for VMX execution.",
    "VERR_VMX_UNSUPPORTED_MODE",
     VERR_VMX_UNSUPPORTED_MODE }, 
  { "Unable to start VM execution.",
    "Unable to start VM execution.",
    "VERR_VMX_UNABLE_TO_START_VM",
     VERR_VMX_UNABLE_TO_START_VM }, 
  { "Unable to resume VM execution.",
    "Unable to resume VM execution.",
    "VERR_VMX_UNABLE_TO_RESUME_VM",
     VERR_VMX_UNABLE_TO_RESUME_VM }, 
  { "Unable to switch due to invalid host state.",
    "Unable to switch due to invalid host state.",
    "VERR_VMX_INVALID_HOST_STATE",
     VERR_VMX_INVALID_HOST_STATE }, 
  { "IA32_FEATURE_CONTROL MSR not setup correcty (turn on VMX in the host system BIOS).",
    "IA32_FEATURE_CONTROL MSR not setup correcty (turn on VMX in the host system BIOS).",
    "VERR_VMX_ILLEGAL_FEATURE_CONTROL_MSR",
     VERR_VMX_ILLEGAL_FEATURE_CONTROL_MSR }, 
  { "VMX CPU extension not available.",
    "VMX CPU extension not available.",
    "VERR_VMX_NO_VMX",
     VERR_VMX_NO_VMX }, 
  { "VMXON failed; possibly because it was already run before.",
    "VMXON failed; possibly because it was already run before.",
    "VERR_VMX_VMXON_FAILED",
     VERR_VMX_VMXON_FAILED }, 
  { "CPU was incorrectly left in VMX root mode; incompatible with VirtualBox.",
    "CPU was incorrectly left in VMX root mode; incompatible with VirtualBox.",
    "VERR_VMX_IN_VMX_ROOT_MODE",
     VERR_VMX_IN_VMX_ROOT_MODE }, 
  { "Somebody cleared X86_CR4_VMXE in the CR4 register.",
    "Somebody cleared X86_CR4_VMXE in the CR4 register.",
    "VERR_VMX_X86_CR4_VMXE_CLEARED",
     VERR_VMX_X86_CR4_VMXE_CLEARED }, 
  { "VT-x features locked or unavailable in MSR.",
    "VT-x features locked or unavailable in MSR.",
    "VERR_VMX_MSR_LOCKED_OR_DISABLED",
     VERR_VMX_MSR_LOCKED_OR_DISABLED }, 
  { "Unable to switch due to invalid guest state.",
    "Unable to switch due to invalid guest state.",
    "VERR_VMX_INVALID_GUEST_STATE",
     VERR_VMX_INVALID_GUEST_STATE }, 
  { "Unexpected VM exit code.",
    "Unexpected VM exit code.",
    "VERR_VMX_UNEXPECTED_EXIT_CODE",
     VERR_VMX_UNEXPECTED_EXIT_CODE }, 
  { "Unexpected VM exception code.",
    "Unexpected VM exception code.",
    "VERR_VMX_UNEXPECTED_EXCEPTION",
     VERR_VMX_UNEXPECTED_EXCEPTION }, 
  { "Unexpected interruption exit code.",
    "Unexpected interruption exit code.",
    "VERR_VMX_UNEXPECTED_INTERRUPTION_EXIT_CODE",
     VERR_VMX_UNEXPECTED_INTERRUPTION_EXIT_CODE }, 
  { "CPU is not in VMX root mode; unexpected when leaving VMX root mode.",
    "CPU is not in VMX root mode; unexpected when leaving VMX root mode.",
    "VERR_VMX_NOT_IN_VMX_ROOT_MODE",
     VERR_VMX_NOT_IN_VMX_ROOT_MODE }, 
  { "Unable to start VM execution.",
    "Unable to start VM execution.",
    "VERR_SVM_UNABLE_TO_START_VM",
     VERR_SVM_UNABLE_TO_START_VM }, 
  { "AMD-V bit not set in K6_EFER MSR.",
    "AMD-V bit not set in K6_EFER MSR.",
    "VERR_SVM_ILLEGAL_EFER_MSR",
     VERR_SVM_ILLEGAL_EFER_MSR }, 
  { "AMD-V CPU extension not available.",
    "AMD-V CPU extension not available.",
    "VERR_SVM_NO_SVM",
     VERR_SVM_NO_SVM }, 
  { "AMD-V CPU extension disabled (by BIOS).",
    "AMD-V CPU extension disabled (by BIOS).",
    "VERR_SVM_DISABLED",
     VERR_SVM_DISABLED }, 
  { "AMD-V CPU extension in-use.",
    "AMD-V CPU extension in-use.",
    "VERR_SVM_IN_USE",
     VERR_SVM_IN_USE }, 
  { "Unable to start VM execution.",
    "Unable to start VM execution.",
    "VERR_HWACCM_UNKNOWN_CPU",
     VERR_HWACCM_UNKNOWN_CPU }, 
  { "No CPUID support.",
    "No CPUID support.",
    "VERR_HWACCM_NO_CPUID",
     VERR_HWACCM_NO_CPUID }, 
  { "Host is about to go into suspend mode.",
    "Host is about to go into suspend mode.",
    "VERR_HWACCM_SUSPEND_PENDING",
     VERR_HWACCM_SUSPEND_PENDING }, 
  { "Conflicting CFGM values.",
    "Conflicting CFGM values.",
    "VERR_HWACCM_CONFIG_MISMATCH",
     VERR_HWACCM_CONFIG_MISMATCH }, 
  { "Internal processing error in the HM init code.",
    "Internal processing error in the HM init code.",
    "VERR_HM_ALREADY_ENABLED_IPE",
     VERR_HM_ALREADY_ENABLED_IPE }, 
  { "Unexpected MSR in the load / restore list.",
    "Unexpected MSR in the load / restore list.",
    "VERR_HM_UNEXPECTED_LD_ST_MSR",
     VERR_HM_UNEXPECTED_LD_ST_MSR }, 
  { "No 32-bit to 64-bit switcher in place.",
    "No 32-bit to 64-bit switcher in place.",
    "VERR_HM_NO_32_TO_64_SWITCHER",
     VERR_HM_NO_32_TO_64_SWITCHER }, 
  { "Invalid pVMCB.",
    "Invalid pVMCB.",
    "VERR_HMSVM_INVALID_PVMCB",
     VERR_HMSVM_INVALID_PVMCB }, 
  { "Unexpected SVM exit.",
    "Unexpected SVM exit.",
    "VERR_HMSVM_UNEXPECTED_EXIT",
     VERR_HMSVM_UNEXPECTED_EXIT }, 
  { "Unexpected SVM exception exit.",
    "Unexpected SVM exception exit.",
    "VERR_HMSVM_UNEXPECTED_XCPT_EXIT",
     VERR_HMSVM_UNEXPECTED_XCPT_EXIT }, 
  { "Unexpected SVM patch type.",
    "Unexpected SVM patch type.",
    "VERR_HMSVM_UNEXPECTED_PATCH_TYPE",
     VERR_HMSVM_UNEXPECTED_PATCH_TYPE }, 
  { "HWACCMR0Leave was called on the wrong CPU.",
    "HWACCMR0Leave was called on the wrong CPU.",
    "VERR_HM_WRONG_CPU_1",
     VERR_HM_WRONG_CPU_1 }, 
  { "Internal processing error #1 in the HM code.",
    "Internal processing error #1 in the HM code.",
    "VERR_HM_IPE_1",
     VERR_HM_IPE_1 }, 
  { "Internal processing error #2 in the HM code.",
    "Internal processing error #2 in the HM code.",
    "VERR_HM_IPE_2",
     VERR_HM_IPE_2 }, 
  { "Wrong 32/64-bit switcher.",
    "Wrong 32/64-bit switcher.",
    "VERR_HM_WRONG_SWITCHER",
     VERR_HM_WRONG_SWITCHER }, 
  { "Unknown I/O instruction.",
    "Unknown I/O instruction.",
    "VERR_HM_UNKNOWN_IO_INSTRUCTION",
     VERR_HM_UNKNOWN_IO_INSTRUCTION }, 
  { "Invalid opcode byte(s).",
    "Invalid opcode byte(s).",
    "VERR_DIS_INVALID_OPCODE",
     VERR_DIS_INVALID_OPCODE }, 
  { "Generic failure during disassembly.",
    "Generic failure during disassembly.",
    "VERR_DIS_GEN_FAILURE",
     VERR_DIS_GEN_FAILURE }, 
  { "Authentication failed (ISessionManager::logon()).",
    "Authentication failed (ISessionManager::logon()).",
    "VERR_WEB_NOT_AUTHENTICATED",
     VERR_WEB_NOT_AUTHENTICATED }, 
  { "Invalid format of managed object reference.",
    "Invalid format of managed object reference.",
    "VERR_WEB_INVALID_MANAGED_OBJECT_REFERENCE",
     VERR_WEB_INVALID_MANAGED_OBJECT_REFERENCE }, 
  { "Invalid session ID in managed object reference.",
    "Invalid session ID in managed object reference.",
    "VERR_WEB_INVALID_SESSION_ID",
     VERR_WEB_INVALID_SESSION_ID }, 
  { "Invalid object ID in managed object reference.",
    "Invalid object ID in managed object reference.",
    "VERR_WEB_INVALID_OBJECT_ID",
     VERR_WEB_INVALID_OBJECT_ID }, 
  { "Unsupported interface for managed object reference.",
    "Unsupported interface for managed object reference.",
    "VERR_WEB_UNSUPPORTED_INTERFACE",
     VERR_WEB_UNSUPPORTED_INTERFACE }, 
  { "Switch back to host.",
    "Switch back to host.",
    "VINF_PARAV_SWITCH_TO_HOST",
     VINF_PARAV_SWITCH_TO_HOST }, 
  { "command processing is pending, a completion handler will be called.",
    "command processing is pending, a completion handler will be called.",
    "VINF_VHWA_CMD_PENDING",
     VINF_VHWA_CMD_PENDING }, 
  { "Unexpected turn of events.",
    "Unexpected turn of events.",
    "VERR_COM_UNEXPECTED",
     VERR_COM_UNEXPECTED }, 
  { "The base of the VirtualBox COM status codes (the lower value) corresponding 1:1 to VBOX_E_XXX.",
    "The base of the VirtualBox COM status codes (the lower value) corresponding 1:1 to VBOX_E_XXX. This is the lowest value.",
    "VERR_COM_VBOX_LOWEST",
     VERR_COM_VBOX_LOWEST }, 
  { "Object corresponding to the supplied arguments does not exist.",
    "Object corresponding to the supplied arguments does not exist.",
    "VERR_COM_OBJECT_NOT_FOUND",
     VERR_COM_OBJECT_NOT_FOUND }, 
  { "Current virtual machine state prevents the operation.",
    "Current virtual machine state prevents the operation.",
    "VERR_COM_INVALID_VM_STATE",
     VERR_COM_INVALID_VM_STATE }, 
  { "Virtual machine error occurred attempting the operation.",
    "Virtual machine error occurred attempting the operation.",
    "VERR_COM_VM_ERROR",
     VERR_COM_VM_ERROR }, 
  { "File not accessible or erroneous file contents.",
    "File not accessible or erroneous file contents.",
    "VERR_COM_FILE_ERROR",
     VERR_COM_FILE_ERROR }, 
  { "IPRT error.",
    "IPRT error.",
    "VERR_COM_IPRT_ERROR",
     VERR_COM_IPRT_ERROR }, 
  { "Pluggable Device Manager error.",
    "Pluggable Device Manager error.",
    "VERR_COM_PDM_ERROR",
     VERR_COM_PDM_ERROR }, 
  { "Current object state prohibits operation.",
    "Current object state prohibits operation.",
    "VERR_COM_INVALID_OBJECT_STATE",
     VERR_COM_INVALID_OBJECT_STATE }, 
  { "Host operating system related error.",
    "Host operating system related error.",
    "VERR_COM_HOST_ERROR",
     VERR_COM_HOST_ERROR }, 
  { "Requested operation is not supported.",
    "Requested operation is not supported.",
    "VERR_COM_NOT_SUPPORTED",
     VERR_COM_NOT_SUPPORTED }, 
  { "Invalid XML found.",
    "Invalid XML found.",
    "VERR_COM_XML_ERROR",
     VERR_COM_XML_ERROR }, 
  { "Current session state prohibits operation.",
    "Current session state prohibits operation.",
    "VERR_COM_INVALID_SESSION_STATE",
     VERR_COM_INVALID_SESSION_STATE }, 
  { "Object being in use prohibits operation.",
    "Object being in use prohibits operation.",
    "VERR_COM_OBJECT_IN_USE",
     VERR_COM_OBJECT_IN_USE }, 
  { "Returned by callback methods which does not need to be called again because the client does not actually make use of them.",
    "Returned by callback methods which does not need to be called again because the client does not actually make use of them.",
    "VERR_COM_DONT_CALL_AGAIN",
     VERR_COM_DONT_CALL_AGAIN }, 
  { "CPU hotplug events from VMMDev are not monitored by the guest.",
    "CPU hotplug events from VMMDev are not monitored by the guest.",
    "VERR_CPU_HOTPLUG_NOT_MONITORED_BY_GUEST",
     VERR_CPU_HOTPLUG_NOT_MONITORED_BY_GUEST }, 
  { "Async I/O task is pending, a completion handler will be called.",
    "Async I/O task is pending, a completion handler will be called.",
    "VINF_AIO_TASK_PENDING",
     VINF_AIO_TASK_PENDING }, 
  { "LUN type is not supported.",
    "LUN type is not supported.",
    "VERR_VSCSI_LUN_TYPE_NOT_SUPPORTED",
     VERR_VSCSI_LUN_TYPE_NOT_SUPPORTED }, 
  { "LUN is already/still attached to a device.",
    "LUN is already/still attached to a device.",
    "VERR_VSCSI_LUN_ATTACHED_TO_DEVICE",
     VERR_VSCSI_LUN_ATTACHED_TO_DEVICE }, 
  { "The specified LUN is invalid.",
    "The specified LUN is invalid.",
    "VERR_VSCSI_LUN_INVALID",
     VERR_VSCSI_LUN_INVALID }, 
  { "The LUN is not attached to the device.",
    "The LUN is not attached to the device.",
    "VERR_VSCSI_LUN_NOT_ATTACHED",
     VERR_VSCSI_LUN_NOT_ATTACHED }, 
  { "The LUN is still busy.",
    "The LUN is still busy.",
    "VERR_VSCSI_LUN_BUSY",
     VERR_VSCSI_LUN_BUSY }, 
  { "FAM failed to open a connection.",
    "FAM failed to open a connection.",
    "VERR_FAM_OPEN_FAILED",
     VERR_FAM_OPEN_FAILED }, 
  { "FAM failed to add a file to the list to be monitored.",
    "FAM failed to add a file to the list to be monitored.",
    "VERR_FAM_MONITOR_FILE_FAILED",
     VERR_FAM_MONITOR_FILE_FAILED }, 
  { "FAM failed to add a directory to the list to be monitored.",
    "FAM failed to add a directory to the list to be monitored.",
    "VERR_FAM_MONITOR_DIRECTORY_FAILED",
     VERR_FAM_MONITOR_DIRECTORY_FAILED }, 
  { "The connection to the FAM daemon was lost.",
    "The connection to the FAM daemon was lost.",
    "VERR_FAM_CONNECTION_LOST",
     VERR_FAM_CONNECTION_LOST }, 
  { "RamPreAlloc not set.",
    "RamPreAlloc not set. RAM pre-allocation is currently a requirement for PCI passthrough.",
    "VERR_PCI_PASSTHROUGH_NO_RAM_PREALLOC",
     VERR_PCI_PASSTHROUGH_NO_RAM_PREALLOC }, 
  { "VT-x/AMD-V not active.",
    "VT-x/AMD-V not active. PCI passthrough currently works only if VT-x/AMD-V is active.",
    "VERR_PCI_PASSTHROUGH_NO_HWACCM",
     VERR_PCI_PASSTHROUGH_NO_HWACCM }, 
  { "Nested paging not active.",
    "Nested paging not active. PCI passthrough currently works only if nested paging is active.",
    "VERR_PCI_PASSTHROUGH_NO_NESTED_PAGING",
     VERR_PCI_PASSTHROUGH_NO_NESTED_PAGING }, 
  { "Internal error obtaining the GVMM instance.",
    "Internal error obtaining the GVMM instance.",
    "VERR_GVMM_INSTANCE",
     VERR_GVMM_INSTANCE }, 
  { "GVMM does not support the range of CPUs present/possible on the host.",
    "GVMM does not support the range of CPUs present/possible on the host.",
    "VERR_GVMM_HOST_CPU_RANGE",
     VERR_GVMM_HOST_CPU_RANGE }, 
  { "GVMM ran into some broken IPRT code.",
    "GVMM ran into some broken IPRT code.",
    "VERR_GVMM_BROKEN_IPRT",
     VERR_GVMM_BROKEN_IPRT }, 
  { "Internal processing error #1 in the GVMM code.",
    "Internal processing error #1 in the GVMM code.",
    "VERR_GVMM_IPE_1",
     VERR_GVMM_IPE_1 }, 
  { "Internal processing error #2 in the GVMM code.",
    "Internal processing error #2 in the GVMM code.",
    "VERR_GVMM_IPE_2",
     VERR_GVMM_IPE_2 }, 
  { "The host is not supported.",
    "The host is not supported. Uninstall the extension pack. Returned by the VBOXEXTPACKREG::pfnInstalled.",
    "VERR_EXTPACK_UNSUPPORTED_HOST_UNINSTALL",
     VERR_EXTPACK_UNSUPPORTED_HOST_UNINSTALL }, 
  { "The VirtualBox version is not supported by one of the extension packs.",
    "The VirtualBox version is not supported by one of the extension packs.\nYou have probably upgraded VirtualBox recently. Please upgrade the extension packs to versions compatible with this VirtualBox release.",
    "VERR_EXTPACK_VBOX_VERSION_MISMATCH",
     VERR_EXTPACK_VBOX_VERSION_MISMATCH }, 
